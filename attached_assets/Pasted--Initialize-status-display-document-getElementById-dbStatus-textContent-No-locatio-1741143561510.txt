  // Initialize status display
        document.getElementById("dbStatus").textContent = "No location selected";

        // Load the last location on initialization
        this.loadLastLocation();
      },
      setupDrawTools: function() {
        const drawOptions = { shapeOptions: { color: "#3388ff" } };
        this.drawTools = {
          polygon: new L.Draw.Polygon(this.map, { allowIntersection: false, showArea: true, drawError: { color: "#e1e100", timeout: 1000 }, shapeOptions: { color: "#3388ff" } }),
          polyline: new L.Draw.Polyline(this.map, drawOptions),
          rectangle: new L.Draw.Rectangle(this.map, drawOptions),
          circle: new L.Draw.Circle(this.map, drawOptions),
          marker: new L.Draw.Marker(this.map)
        };
        this.map.on("draw:created", (e) => {
          const layer = e.layer;
          if (e.layerType === "polygon") {
            const coords = layer.getLatLngs()[0];
            if (coords.length > 0 && !coords[0].equals(coords[coords.length - 1])) {
              coords.push(coords[0]);
              layer.setLatLngs(coords);
            }
            // Removed prompt for polygon type
            layer.feature = layer.toGeoJSON();
          }
          this.activeLayer.addLayer(layer);
          this.deactivateAllTools();
          this.saveProject();
        });
        this.map.on("draw:edited", () => this.saveProject());
        this.map.on("draw:deleted", () => this.saveProject());
      },
      activateTool: function(toolName, buttonId) {
        this.deactivateAllTools();
        if (this.drawTools[toolName]) {
          this.drawTools[toolName].enable();
          document.getElementById(buttonId).classList.add("active");
        }
      },
      deactivateAllTools: function() {
        for (let tool in this.drawTools) this.drawTools[tool].disable();
        document.querySelectorAll(".tool-button").forEach(btn => btn.classList.remove("active"));
        document.getElementById("panTool").classList.add("active");
      },
      updateDrawToLayerSelect: function() {
        const sel = document.getElementById("drawToLayer");
        sel.innerHTML = "";

        // Add all existing layers to the dropdown
        for (let key in this.layers) {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = key;

          // Select the active layer
          if (this.activeLayer === this.layers[key]) {
            opt.selected = true;
          }

          sel.appendChild(opt);
        }

        // If no layers exist, create a default one
        if (Object.keys(this.layers).length === 0) {
          const opt = document.createElement("option");
          opt.value = "Default";
          opt.textContent = "Default";
          opt.selected = true;
          sel.appendChild(opt);

          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;
        }

        // When layer selection changes, update the active layer
        sel.onchange = () => {
          this.switchDrawToLayer();
        };
      },
      switchDrawToLayer: function() {
        const layerName = document.getElementById("drawToLayer").value;
        if (layerName && this.layers[layerName]) {
          this.activeLayer = this.layers[layerName];

          // Update draw controls with layer-specific styles
          if (layerName === "PES") {
            this.updateDrawStyles('red');
          } else if (layerName === "ES") {
            this.updateDrawStyles('green');
          } else {
            this.updateDrawStyles(null); // Reset to default
          }
        }
      },
      updateDrawStyles: function(color) {
        if (!color) {
          // Use defaults if no color specified
          const drawOptions = { shapeOptions: { color: "#3388ff" } };
          for (let type in this.drawTools) {
            if (this.drawTools[type]) {
              this.drawTools[type].options.shapeOptions = drawOptions.shapeOptions;
            }
          }
          return;
        }

        const styleOptions = {
          shapeOptions: {
            color: color,
            fillColor: color,
            fillOpacity: 0.3
          }
        };

        // Update all draw controls with the new style
        for (let type in this.drawTools) {
          if (this.drawTools[type] && this.drawTools[type].options && this.drawTools[type].options.shapeOptions) {
            Object.assign(this.drawTools[type].options.shapeOptions, styleOptions.shapeOptions);
          }
        }
      },
      toggleBaseLayerDropdown: function() {
        const dropdown = document.getElementById("baseLayerDropdown");
        if (dropdown.style.display === "block") {
          dropdown.style.display = "none";
        } else {
          dropdown.innerHTML = "";
          for (let name in this.baseLayers) {
            const div = document.createElement("div");
            div.textContent = name;
            div.style.cursor = "pointer";
            div.style.padding = "5px";
            div.addEventListener("click", () => {
              this.switchBaseLayer(name);
              dropdown.style.display = "none";
              this.saveProject();
            });
            dropdown.appendChild(div);
          }
          const btn = document.getElementById("baseLayerTool");
          let rect = btn.getBoundingClientRect();
          dropdown.style.top = rect.bottom + "px";
          dropdown.style.left = rect.left + "px";
          dropdown.style.display = "block";
        }
      },
      switchBaseLayer: function(name) {
        if (this.currentBaseLayer) this.map.removeLayer(this.currentBaseLayer);
        this.currentBaseLayer = this.baseLayers[name];
        this.currentBaseLayer.addTo(this.map);
      },
      showAddLayerModal: function() { document.getElementById("addLayerModal").classList.add("visible"); },
      closeAddLayerModal: function() {
        document.getElementById("addLayerModal").classList.remove("visible");
        document.getElementById("newLayerName").value = "";
      },
      createNewLayer: function() {
        let layerName = document.getElementById("newLayerName").value.trim();
        let layerType = document.getElementById("newLayerType").value;
        if (!layerName) { alert("Enter a layer name"); return; }
        if (this.layers[layerName]) { alert(`Layer "${layerName}" exists`); return; }
        let newLayer = L.featureGroup().addTo(this.map);
        newLayer.properties = { type: layerType };
        this.layers[layerName] = newLayer;
        this.activeLayer = newLayer;
        this.updateDrawToLayerSelect();
        this.closeAddLayerModal();
        console.log(`Created layer: ${layerName}, type: ${layerType}`);
        this.saveProject();
      },
      showNewLocationModal: function() { document.getElementById("newLocationModal").classList.add("visible"); },
      closeNewLocationModal: function() { document.getElementById("newLocationModal").classList.remove("visible"); },
      createNewLocation: async function() {
        let locName = document.getElementById("newLocationName").value.trim();
        if (!locName) { alert("Enter a location name"); return; }
        try {
          const response = await fetch("/api/create_location", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ location_name: locName })
          });
          const data = await response.json();
          this.currentLocationId = data.id;
          this.currentLocationName = data.name; // Store location name
          document.getElementById("dbStatus").textContent = `Location: ${data.name}`;
          for (let key in this.layers) this.map.removeLayer(this.layers[key]);
          this.layers = {};
          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;
          this.updateDrawToLayerSelect();
          this.closeNewLocationModal();
          console.log("Created new location:", data);
          this.saveProject();
        } catch (e) {
          console.error("Error creating location:", e);
          alert("Failed to create location");
        }
      },
      showSwitchLocationModal: async function() {
        document.getElementById("switchLocationModal").classList.add("visible");
        let locationList = document.getElementById("locationList");
        locationList.innerHTML = "";
        try {
          const response = await fetch("/api/locations");
          const data = await response.json();
          data.locations.forEach(loc => {
            let div = document.createElement("div");
            div.style.padding = "10px";
            div.style.borderBottom = "1px solid #eee";
            div.style.cursor = "pointer";
            div.textContent = `${loc.name} (Created: ${new Date(loc.created_at).toLocaleString()})`;
            div.addEventListener("click", () => this.switchToLocation(loc));
            locationList.appendChild(div);
          });
        } catch (e) {
          console.error("Error loading locations:", e);
          locationList.textContent = "Failed to load locations";
        }
      },
      closeSwitchLocationModal: function() { document.getElementById("switchLocationModal").classList.remove("visible"); },
      switchToLocation: async function(locObj) {
        console.log("Switching to location:", locObj);

        try {
          // Store both location ID and name
          this.currentLocationId = locObj.id;
          this.currentLocationName = locObj.name;
          localStorage.setItem('lastLocationId', this.currentLocationId);
          localStorage.setItem('lastLocationName', this.currentLocationName);

          this.clearLayers();
          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;

          // Update UI to reflect current location
          document.getElementById("dbStatus").textContent = `Location: ${this.currentLocationName}`;

          this.updateDrawToLayerSelect();
          await this.loadProject();
          this.closeSwitchLocationModal();
        } catch (error) {
          console.error("Error switching location:", error);
          alert(`Failed to switch to location "${locObj.name}". Please try again.`);
          document.getElementById("dbStatus").textContent = `Error loading location: ${this.currentLocationName}`;
        }
      },
      saveProject: async function() {
        let projectData = { layers: {} };

        for (let layerName in this.layers) {
          const layer = this.layers[layerName];
          if (!layer) continue;

          // Extract features from the layer
          let features = [];
          layer.eachLayer(function(l) {
            if (l.toGeoJSON) {
              let feature = l.toGeoJSON();
              // Store the layer name in the feature properties
              feature.properties = feature.properties || {};
              feature.properties.layerName = layerName;

              if (l._popup) {
                feature.properties.popupContent = l._popup._content;
              }
              features.push(feature);
            }
          });

          projectData.layers[layerName] = {
            features: features
          };
        }

        // Save to localStorage
        localStorage.setItem('qdproProject', JSON.stringify(projectData));
      },
      loadProject: async function() {
        try {
          const url = this.currentLocationId ? `/api/load-layers?location_id=${this.currentLocationId}` : "/api/load-layers";
          const response = await fetch(url);
          const data = await response.json();
          for (let key in this.layers) this.layers[key].clearLayers();
          if (data.layers && data.layers.features && data.layers.features.length > 0) {
            data.layers.features.forEach(feature => {
              if (feature.layerName) { // Check if layerName exists
                let layer = this.layers[feature.layerName];
                if (!layer) {
                  layer = L.featureGroup().addTo(this.map);
                  this.layers[feature.layerName] = layer;
                }
                let layerStyle = {};
                if (feature.properties && feature.properties.layerName === "PES") {
                  layerStyle = {
                    color: 'red',
                    fillColor: 'red',
                    fillOpacity: 0.3
                  };
                } else if (feature.properties && feature.properties.layerName === "ES") {
                  layerStyle = {
                    color: 'green',
                    fillColor: 'green',
                    fillOpacity: 0.3
                  };
                }
                L.geoJSON(feature, {
                  style: layerStyle,
                  onEachFeature: (f, l) => {
                    if (f.properties && f.properties.type) {
                      l.bindPopup("Type: " + f.properties.type);
                    }
                    layer.addLayer(l);
                  }
                });
              }
            });
            this.updateDrawToLayerSelect(); //Added to update select after load.

            // Set the first layer as active if available
            const layerNames = Object.keys(this.layers);
            if (layerNames.length > 0) {
              const selectElement = document.getElementById("drawToLayer");
              if (selectElement) {
                selectElement.value = layerNames[0];
                this.switchDrawToLayer(); // Apply styling based on selected layer
              }
            }

            // Only try to fit bounds if there are valid layers with features
            if (Object.keys(this.layers).length > 0) {
              try {
                // First check which layers have valid bounds
                let hasValidBounds = false;
                let bounds = L.latLngBounds([]);

                for (let layerName in this.layers) {
                  const layer = this.layers[layerName];
                  // Only extend bounds if the layer has features
                  if (layer.getLayers().length > 0) {
                    try {
                      const layerBounds = layer.getBounds();
                      if (layerBounds.isValid()) {
                        bounds.extend(layerBounds);
                        hasValidBounds = true;
                      }
                    } catch (e) {
                      console.warn(`Layer ${layerName} has invalid bounds:`, e);
                    }
                  }
                }

                // Only fit bounds if we have valid bounds
                if (hasValidBounds) {
                  this.map.fitBounds(bounds);
                } else {
                  console.log("No valid bounds found, using default view");
                }
              } catch (e) {
                console.warn("Error fitting bounds:", e);
                // Use default view if bounds fitting fails
              }
            }
            console.log("Project loaded:", data);
          } else {
            console.log("No project features found.");
          }
        } catch (e) {
          console.error("Error loading project:", e);
          alert("Failed to load project");
        }
      },
      clearLayers: function() {
        for (let key in this.layers) {
          this.map.removeLayer(this.layers[key]);
        }
        this.layers = {};
      },

      getLayerNameByObject: function(layerObj) {
        for (let name in this.layers) {
          if (this.layers[name] === layerObj) {
            return name;
          }
        }
        return null;
      },
      loadLastLocation: async function() {
        const lastLocationId = localStorage.getItem('lastLocationId');
        const lastLocationName = localStorage.getItem('lastLocationName');

        if (lastLocationId && lastLocationName) {
          console.log("Loading last used location:", lastLocationName);
          try {
            this.currentLocationId = lastLocationId;
            this.currentLocationName = lastLocationName;
            document.getElementById("dbStatus").textContent = `Location: ${this.currentLocationName}`;
            this.clearLayers();
            this.activeLayer = L.featureGroup().addTo(this.map);
            this.layers["Default"] = this.activeLayer;
            this.updateDrawToLayerSelect();
            await this.loadProject();
          } catch (error) {
            console.error("Error loading last location:", error);
          }
        }
      }
    };

    function showNewLocationModal() { QDPro.showNewLocationModal(); }
    function closeNewLocationModal() { QDPro.closeNewLocationModal(); }
    function createNewLocation() { QDPro.createNewLocation(); }
    function showSwitchLocationModal() { QDPro.showSwitchLocationModal(); }
    function closeSwitchLocationModal() { QDPro.closeSwitchLocationModal(); }
    function showAddLayerModal() { QDPro.showAddLayerModal(); }
    function closeAddLayerModal() { QDPro.closeAddLayerModal(); }
    function createNewLayer() { QDPro.createNewLayer(); }
    function saveProject() { QDPro.saveProject(); }
    function loadProject() { QDPro.loadProject(); }

    document.addEventListener("DOMContentLoaded", () => QDPro.init());
  </script>
  <!-- Custom modal script -->
  <script src="/static/js/custom-modal.js"></script>
  <!-- End of your existing scripts -->
</body>
</html>