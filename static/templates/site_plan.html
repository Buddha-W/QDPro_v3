<!DOCTYPE html>
<html>
<head>
  <title>QDPro – Working Example with Persistence</title>

  <!-- Load Leaflet JavaScript with defer to ensure proper loading order -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" defer></script>

  <!-- Load feature editor early to ensure global functions are available -->
  <script src="/static/js/feature-editor.js" defer></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" crossorigin="anonymous"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous"/>
  <script src="/static/js/popup-handler.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; height: 100vh; overflow: hidden; }
    nav.main-toolbar {
      position: fixed; top: 0; left: 0; right: 0;
      height: 40px; background: #f1f1f1; border-bottom: 1px solid #ccc;
      display: flex; align-items: center; z-index: 3000; padding: 0 10px;
      white-space: nowrap;
    }
    .menu-item { padding: 0 15px; font-size: 14px; display: flex; align-items: center; cursor: pointer; position: relative; }
    .menu-item:hover { background: #e9ecef; }
    .menu-dropdown { display: none; position: fixed; background: white; min-width: 150px; border: 1px solid #ccc; border-radius: 4px; z-index: 3500; }
    .menu-dropdown-item { padding: 8px 12px; font-size: 14px; cursor: pointer; }
    .menu-dropdown-item:hover { background: #f0f0f0; }
    #dbStatus { margin-left: auto; }
    .toolbar { position: fixed; top: 40px; left: 0; right: 0; height: 40px; background: #fff; border-bottom: 1px solid #ccc; display: flex; align-items: center; z-index: 2900; padding: 0 10px; }
    .tool-group { display: flex; align-items: center; margin-right: 10px; }
    .tool-button { padding: 6px; margin: 0 2px; border: 1px solid transparent; border-radius: 3px; background: #fff; color: #666; cursor: pointer; display: flex; align-items: center; justify-content: center; min-width: 32px; height: 32px; }
    .tool-button:hover { background: #f0f0f0; border-color: #ccc; }
    .tool-button.active { background: #e6f2ff; border-color: #99ccff; color: #0066cc; }
    #map { position: fixed; top: 80px; left: 0; right: 0; bottom: 0; z-index: 1000; background: #eee; }
    .left-panel { position: fixed; top: 80px; left: 0; width: 300px; height: calc(100vh - 80px); background: white; border-right: 1px solid #ccc; transform: translateX(-300px); transition: transform 0.3s ease; z-index: 1500; display: flex; flex-direction: column; }
    .left-panel.visible { transform: translateX(0); }
    .panel-header { padding: 15px; background: #f8f9fa; border-bottom: 1px solid #ccc; font-weight: bold; }
    .panel-content { padding: 15px; flex-grow: 1; overflow-y: auto; }
    .base-layer-dropdown { position: fixed; background: white; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); z-index: 2800; display: none; }
    .modal-overlay { display: none; position: fixed; z-index: 4000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); align-items: center; justify-content: center; }
    .modal-overlay.visible { display: flex; }
    .modal-content { background: #fff; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; }
    .modal-content h2 { margin-bottom: 15px; }
    .modal-content input, .modal-content select, .modal-content textarea { width: 100%; padding: 5px; margin-top: 5px; margin-bottom: 10px; }
    .modal-content button { margin: 5px; }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
    .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; }
    .facility-icon { text-align: center; }
    .violation-icon { text-align: center; }
    .facility-icon div, .violation-icon div {
      background-color: #fff;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #333;
    }
    .facility-icon div {
      background-color: #ffcc00;
      border-color: #cc9900;
    }
    .violation-icon div {
      background-color: #ff3300;
      border-color: #cc0000;
    }
    .analysis-summary-panel {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      max-width: 300px;
    }
    .analysis-popup, .qd-ring-popup, .violation-popup {
      max-width: 250px;
    }
    .close-btn {
      background: #f44336;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    .close-btn:hover {
      background: #d32f2f;
    }
  </style>
</head>
<body>
  <nav class="main-toolbar">
    <div class="menu-item" onclick="toggleMenu(this, 'fileMenu')">File
      <div class="menu-dropdown" id="fileMenu">
        <div class="menu-dropdown-item" onclick="showNewLocationModal()">New Location</div>
        <div class="menu-dropdown-item" onclick="showSwitchLocationModal()">Switch Location</div>
        <div class="menu-dropdown-item" onclick="saveProject()">Save Project</div>
        <div class="menu-dropdown-item" onclick="loadProject()">Load Project</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'editMenu')">Edit
      <div class="menu-dropdown" id="editMenu">
        <div class="menu-dropdown-item">Cut</div>
        <div class="menu-dropdown-item">Copy</div>
        <div class="menu-dropdown-item">Paste</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'viewMenu')">View
      <div class="menu-dropdown" id="viewMenu">
        <div class="menu-dropdown-item">Layers</div>
        <div class="menu-dropdown-item">Base Maps</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'toolsMenu')">Tools
      <div class="menu-dropdown" id="toolsMenu">
        <div class="menu-dropdown-item" onclick="showMeasurementTool()">QD Calculator</div>
        <div class="menu-dropdown-item" onclick="clearMeasurements()">Measure</div>
        <div class="menu-dropdown-item" onclick="QDPro.analyzeLocation()">Analyze Location</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'helpMenu')">Help
      <div class="menu-dropdown" id="helpMenu">
        <div class="menu-dropdown-item">Documentation</div>
        <div class="menu-dropdown-item">About</div>
      </div>
    </div>
    <div id="dbStatus">No location selected</div>
  </nav>

  <div class="toolbar">
    <div class="tool-group">
      <button id="toggleLayersPanel" class="tool-button" title="Toggle Layers Panel"><i class="fas fa-bars"></i></button>
      <button id="baseLayerTool" class="tool-button" title="Base Layers"><i class="fas fa-layer-group"></i></button>
    </div>
    <div class="tool-group">
      <button id="zoomInBtn" class="tool-button" title="Zoom In"><i class="fas fa-search-plus"></i></button>
      <button id="zoomOutBtn" class="tool-button" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
    </div>
    <div class="tool-group">
      <button id="selectTool" class="tool-button" title="Select Features"><i class="fas fa-mouse-pointer"></i></button>
      <button id="panTool" class="tool-button active" title="Pan Map"><i class="fas fa-hand-paper"></i></button>
    </div>
    <div class="tool-group">
      <button id="drawMarker" class="tool-button" title="Add Point"><i class="fas fa-map-marker-alt"></i></button>
      <button id="drawPolygon" class="tool-button" title="Draw Polygon"><i class="fas fa-draw-polygon"></i></button>
      <button id="drawRectangle" class="tool-button" title="Draw Rectangle"><i class="fas fa-square"></i></button>
      <button id="drawCircle" class="tool-button" title="Draw Circle"><i class="fas fa-circle"></i></button>
      <button id="drawPolyline" class="tool-button" title="Draw Line"><i class="fas fa-minus"></i></button>
    </div>
  </div>

  <div class="left-panel" id="leftPanel">
    <div class="panel-header">Layers Panel</div>
    <div class="panel-content">
      <div class="layer-select-container">
        <label for="drawToLayer"><strong>Draw to Layer:</strong></label>
        <select id="drawToLayer" style="width: 100%; margin-top: 5px; padding: 5px;"></select>
        <button onclick="showAddLayerModal()" style="margin-top: 10px; width: 100%;">Add New Layer</button>
      </div>
      <div id="layersList" style="margin-top:20px;">
        <h4>Available Layers</h4>
        <ul id="availableLayers" style="list-style: none; padding: 0; margin: 0;"></ul>
      </div>
      <div id="layerEditModal" class="modal-overlay">
        <div class="modal-content">
          <h2>Edit Layer</h2>
          <div style="margin-bottom: 10px;">
            <label for="editLayerName">Layer Name:</label>
            <input type="text" id="editLayerName" style="width: 100%; padding: 5px;">
          </div>
          <div style="margin: 10px 0;">
            <label for="layerType">Layer Type:</label>
            <select id="isQDLayer" name="layerType" style="width: 100%; padding: 5px;">
              <option value="false">Non-QD</option>
              <option value="true">QD Analysis Layer (contains explosives)</option>
            </select>
          </div>
          <div style="margin-bottom: 10px;">
            <label for="layerColor">Layer Color:</label>
            <input type="color" id="layerColor" style="width: 100%; padding: 5px;">
          </div>
          <hr style="margin: 10px 0; border-top: 1px solid #ddd;">
          <div style="text-align:right;">
            <button onclick="closeLayerEditModal()" style="margin-right:10px;">Cancel</button>
            <button onclick="saveLayerEdits()">Save</button>
          </div>
        </div>
      </div>
      <div id="layerControl" style="margin-top:20px;"></div>
    </div>
  </div>

  <div id="baseLayerDropdown" class="base-layer-dropdown"></div>
  <div id="map"></div>

  <div id="newLocationModal" class="modal-overlay">
    <div class="modal-content">
      <h2>Create New Location</h2>
      <input type="text" id="newLocationName" placeholder="Enter location name"/>
      <div style="text-align:right;">
        <button onclick="closeNewLocationModal()" style="margin-right:10px;">Cancel</button>
        <button onclick="createNewLocation()">Create</button>
      </div>
    </div>
  </div>
  <div id="switchLocationModal" class="modal-overlay">
    <div class="modal-content">
      <h2>Switch Location</h2>
      <div id="locationList" style="margin:10px 0; max-height:200px; overflow-y:auto;"></div>
      <div style="text-align:right;">
        <button onclick="closeSwitchLocationModal()">Close</button>
      </div>
    </div>
  </div>
  <div id="addLayerModal" class="modal-overlay">
    <div class="modal-content">
      <h2>Add New Layer</h2>
      <input type="text" id="newLayerName" placeholder="Layer Name"/>
      <select id="newLayerType">
        <option value="facility">Facility</option>
        <option value="boundary">Boundary</option>
      </select>
      <div style="text-align:right;">
        <button onclick="closeAddLayerModal()" style="margin-right:10px;">Cancel</button>
        <button onclick="createNewLayer()">Create</button>
      </div>
    </div>
  </div>

  <!-- Edited Feature Properties Modal -->
  <div id="featurePropertiesModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Feature Properties</h2>
        <span id="closeFeaturePropertiesBtn" class="close" onclick="closeFeaturePropertiesModal()">&times;</span>
      </div>
      <div class="modal-body">
        <form id="featurePropertiesForm">
          <div class="form-group">
            <label for="name">Name:</label>
            <input type="text" id="name" name="name" class="form-control">
          </div>

          <div class="form-group">
            <label for="type">Type:</label>
            <select id="type" name="type" class="form-control">
              <option value="Building">Building</option>
              <option value="Storage">Storage</option>
              <option value="Boundary">Boundary</option>
              <option value="Other">Other</option>
            </select>
          </div>

          <div class="form-group">
            <label for="description">Description:</label>
            <textarea id="description" name="description" class="form-control"></textarea>
          </div>

          <div class="form-group">
            <input type="checkbox" id="is_facility" name="is_facility">
            <label for="is_facility">Is Facility</label>
          </div>

          <div class="form-group">
            <input type="checkbox" id="has_explosive" name="has_explosive">
            <label for="has_explosive">Contains Explosives</label>
          </div>

          <div id="explosiveSection" class="form-group" style="display: none;">
            <label for="net_explosive_weight">Net Explosive Weight (NEW):</label>
            <input type="number" id="net_explosive_weight" name="net_explosive_weight" class="form-control">
          </div>

          <div class="form-actions">
            <button type="button" id="savePropertiesBtn" class="btn btn-primary">Save</button>
            <button type="button" class="btn btn-secondary" onclick="closeFeaturePropertiesModal()">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <script>
    window.toggleMenu = function(element, menuId) {
      const dropdown = document.getElementById(menuId);
      document.querySelectorAll(".menu-dropdown").forEach(dd => {
        if (dd.id !== menuId) { dd.style.display = "none"; dd.parentElement.classList.remove("active"); }
      });
      const isVisible = dropdown.style.display === "block";
      dropdown.style.display = isVisible ? "none" : "block";
      element.classList.toggle("active", !isVisible);
      if (!isVisible) {
        const rect = element.getBoundingClientRect();
        dropdown.style.top = rect.bottom + "px";
        dropdown.style.left = rect.left + "px";
      }
    };

    const QDPro = {
      map: null,
      layers: {},
      activeLayer: null,
      drawTools: {},
      baseLayers: {},
      currentBaseLayer: null,
      currentLocationId: null,
      currentLocationName: null,
      layerColors: {}, // Added to store layer colors
      init: async function() {
        console.log("Initializing QDPro...");

        this.currentLocationId = null;
        this.currentLocationName = null;

        this.map = L.map("map", { center: [39.8283, -98.5795], zoom: 4, zoomControl: false });
        this.baseLayers = {
          "OSM": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "© OpenStreetMap contributors" }),
          "Satellite": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", { attribution: "Tiles © Esri" }),
          "Topographic": L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", { attribution: "Map data: © OpenStreetMap contributors" })
        };
        this.currentBaseLayer = this.baseLayers.OSM;
        this.currentBaseLayer.addTo(this.map);
        this.activeLayer = L.featureGroup().addTo(this.map);
        this.layers["Default"] = this.activeLayer;
        this.setupDrawTools();
        const leftPanel = document.getElementById("leftPanel");
        const mapEl = document.getElementById("map");
        document.getElementById("toggleLayersPanel").addEventListener("click", () => {
          leftPanel.classList.toggle("visible");
          mapEl.style.left = leftPanel.classList.contains("visible") ? "300px" : "0";
          mapEl.style.width = leftPanel.classList.contains("visible") ? "calc(100% - 300px)" : "100%";
          this.map.invalidateSize();

          // Update the layers list when the panel becomes visible
          if (leftPanel.classList.contains("visible")) {
            this.updateLayersList();
          }
        });
        document.getElementById("baseLayerTool").addEventListener("click", () => this.toggleBaseLayerDropdown());
        document.getElementById("zoomInBtn").addEventListener("click", () => this.map.zoomIn());
        document.getElementById("zoomOutBtn").addEventListener("click", () => this.map.zoomOut());
        document.getElementById("drawMarker").addEventListener("click", () => this.activateTool("marker", "drawMarker"));
        document.getElementById("drawPolygon").addEventListener("click", () => this.activateTool("polygon", "drawPolygon"));
        document.getElementById("drawRectangle").addEventListener("click", () => this.activateTool("rectangle", "drawRectangle"));
        document.getElementById("drawCircle").addEventListener("click", () => this.activateTool("circle", "drawCircle"));
        document.getElementById("drawPolyline").addEventListener("click", () => this.activateTool("polyline", "drawPolyline"));
        this.updateDrawToLayerSelect();

        document.getElementById("dbStatus").textContent = "No location selected";

        this.loadProject();
      },
      setupDrawTools: function() {
        const drawOptions = { shapeOptions: { color: "#3388ff" } };
        this.drawTools = {
          polygon: new L.Draw.Polygon(this.map, { allowIntersection: false, showArea: true, drawError: { color: "#e1e100", timeout: 1000 }, shapeOptions: { color: "#3388ff" } }),
          polyline: new L.Draw.Polyline(this.map, drawOptions),
          rectangle: new L.Draw.Rectangle(this.map, drawOptions),
          circle: new L.Draw.Circle(this.map, drawOptions),
          marker: new L.Draw.Marker(this.map)
        };
        this.map.on("draw:created", (e) => {
          const layer = e.layer;
          if (e.layerType === "polygon") {
            const coords = layer.getLatLngs()[0];
            if (coords.length > 0 && !coords[0].equals(coords[coords.length - 1])) {
              coords.push(coords[0]);
              layer.setLatLngs(coords);
            }
          }
          this.handleDrawCreated(e);
        });
        this.map.on("draw:edited", () => this.saveProject());
        this.map.on("draw:deleted", () => this.saveProject());
      },
      handleDrawCreated: function(e) {
        const layer = e.layer;
        const selectedLayer = document.getElementById("drawToLayer").value;

        if (!this.layers[selectedLayer]) {
          this.layers[selectedLayer] = L.featureGroup().addTo(this.map);
        }

        if (this.layerColors[selectedLayer]) {
          if (layer.setStyle) {
            layer.setStyle({
              color: this.layerColors[selectedLayer],
              fillColor: this.layerColors[selectedLayer],
              weight: 3,
              opacity: 1,
              fillOpacity: 0.2
            });
          }
        }

        this.layers[selectedLayer].addLayer(layer);
        this.addLayerClickHandlers(layer);

        this.saveProject();
        console.log("Project saved after creating new shape");
      },
      activateTool: function(toolName, buttonId) {
        this.deactivateAllTools();
        if (this.drawTools[toolName]) {
          this.drawTools[toolName].enable();
          document.getElementById(buttonId).classList.add("active");
        }
      },
      deactivateAllTools: function() {
        for (let tool in this.drawTools) this.drawTools[tool].disable();
        document.querySelectorAll(".tool-button").forEach(btn => btn.classList.remove("active"));
        document.getElementById("panTool").classList.add("active");
      },
      updateDrawToLayerSelect: function() {
        const sel = document.getElementById("drawToLayer");
        sel.innerHTML = "";

        for (let key in this.layers) {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = key;
          if (this.activeLayer === this.layers[key]) {
            opt.selected = true;
          }
          sel.appendChild(opt);
        }

        if (Object.keys(this.layers).length === 0) {
          const opt = document.createElement("option");
          opt.value = "Default";
          opt.textContent = "Default";
          opt.selected = true;
          sel.appendChild(opt);

          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;
        }

        sel.onchange = () => {
          this.switchDrawToLayer();
        };
      },
      switchDrawToLayer: function() {
        const layerName = document.getElementById("drawToLayer").value;
        if (layerName && this.layers[layerName]) {
          this.activeLayer = this.layers[layerName];

          if (layerName === "PES") {
            this.updateDrawStyles('red');
          } else if (layerName === "ES") {
            this.updateDrawStyles('green');
          } else {
            this.updateDrawStyles(null);
          }
        }
      },
      updateDrawStyles: function(color) {
        if (!color) {
          const drawOptions = { shapeOptions: { color: "#3388ff" } };
          for (let type in this.drawTools) {
            if (this.drawTools[type]) {
              this.drawTools[type].options.shapeOptions = drawOptions.shapeOptions;
            }
          }
          return;
        }

        const styleOptions = {
          shapeOptions: {
            color: color,
            fillColor: color,
            fillOpacity: 0.3
          }
        };

        for (let type in this.drawTools) {
          if (this.drawTools[type] && this.drawTools[type].options && this.drawTools[type].options.shapeOptions) {
            Object.assign(this.drawTools[type].options.shapeOptions, styleOptions.shapeOptions);
          }
        }
      },
      toggleBaseLayerDropdown: function() {
        const dropdown = document.getElementById("baseLayerDropdown");
        if (dropdown.style.display === "block") {
          dropdown.style.display = "none";
        } else {
          dropdown.innerHTML = "";
          for (let name in this.baseLayers) {
            const div = document.createElement("div");
            div.textContent = name;
            div.style.cursor = "pointer";
            div.style.padding = "5px";
            div.addEventListener("click", () => {
              this.switchBaseLayer(name);
              dropdown.style.display = "none";
              this.saveProject();
            });
            dropdown.appendChild(div);
          }
          const btn = document.getElementById("baseLayerTool");
          let rect = btn.getBoundingClientRect();
          dropdown.style.top = rect.bottom + "px";
          dropdown.style.left = rect.left + "px";
          dropdown.style.display = "block";
        }
      },
      switchBaseLayer: function(name) {
        if (this.currentBaseLayer) this.map.removeLayer(this.currentBaseLayer);
        this.currentBaseLayer = this.baseLayers[name];
        this.currentBaseLayer.addTo(this.map);
      },
      showAddLayerModal: function() { document.getElementById("addLayerModal").classList.add("visible"); },
      closeAddLayerModal: function() {
        document.getElementById("addLayerModal").classList.remove("visible");
        document.getElementById("newLayerName").value = "";
      },
      createNewLayer: function() {
        let layerName = document.getElementById("newLayerName").value.trim();
        let layerType = document.getElementById("newLayerType").value;
        if (!layerName) { alert("Enter a layer name"); return; }
        if (this.layers[layerName]) { alert(`Layer "${layerName}" exists`); return; }
        let newLayer = L.featureGroup().addTo(this.map);

        // Determine if this is a QD analysis layer based on type
        const isQDLayer = layerType === "facility";

        newLayer.properties = { 
          type: layerType,
          isQDAnalyzed: isQDLayer 
        };

        // Generate a color for the layer
        const layerColor = this.getRandomColor();
        this.layerColors[layerName] = layerColor;

        this.layers[layerName] = newLayer;
        this.activeLayer = newLayer;
        this.updateDrawToLayerSelect();
        this.closeAddLayerModal();
        console.log(`Created layer: ${layerName}, type: ${layerType}, QD layer: ${isQDLayer}`);
        this.saveProject();
      },
      showNewLocationModal: function() { document.getElementById("newLocationModal").classList.add("visible"); },
      closeNewLocationModal: function() { document.getElementById("newLocationModal").classList.remove("visible"); },
      createNewLocation: async function() {
        const locationName = document.getElementById("newLocationName").value.trim();
        if (!locationName) {
          alert("Please enter a location name");
          return;
        }
        try {
          const response = await fetch("/api/create_location", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ location_name: locationName })
          });
          const data = await response.json();
          console.log("Location created:", data);

          // Update status immediately
          document.getElementById('dbStatus').textContent = `Current location: ${data.name}`;

          this.closeNewLocationModal();

          // Switch to the new location
          this.switchToLocation(data.id);

          // Refresh the location list
          this.showSwitchLocationModal();
        } catch (e) {
          console.error("Error creating location:", e);
          alert("Failed to create location");
        }
      },
      showSwitchLocationModal: async function() {
        document.getElementById("switchLocationModal").classList.add("visible");
        let locationList = document.getElementById("locationList");
        locationList.innerHTML = "";
        try {
          const response = await fetch("/api/locations");
          const data = await response.json();
          data.locations.forEach(loc => {
            let div = document.createElement("div");
            div.style.padding = "10px";
            div.style.borderBottom = "1px solid #eee";
            div.style.cursor = "pointer";
            div.textContent = `${loc.name} (Created: ${new Date(loc.created_at).toLocaleString()})`;
            div.addEventListener("click", () => this.switchToLocation(loc.id));
            locationList.appendChild(div);
          });
        } catch (e) {
          console.error("Error loading locations:", e);
          locationList.textContent = "Failed to load locations";
        }
      },
      closeSwitchLocationModal: function() { document.getElementById("switchLocationModal").classList.remove("visible"); },
      switchToLocation: async function(locationId) {
        try {
          const response = await fetch(`/api/load-layers?location_id=${locationId}`);
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Error loading location: ${errorData.error || response.statusText}`);
          }

          const data = await response.json();
          console.log("Location data loaded:", data);

          // Clear existing layers
          this.clearLayers();

          //          // Set current location
          this.currentLocationId = locationId;
          this.currentLocationName = data.name || "Unknown";

          // Update the status display
          document.getElementById('dbStatus').textContent = `Current location: ${data.name}`;

          // Load all layers for this location
          await this.loadProject();

          // Save as last used location in localStorage
          localStorage.setItem('lastLocationId', locationId);
          localStorage.setItem('lastLocationName', data.name);

          // Close the modal after switching
          this.closeSwitchLocationModal();
        } catch (error) {
          console.error("Error switching location:", error);
          setStatusMessage(`Error loading location: ${error.message}`, 'error');
        }
      },
      saveProject: function() {
        try {
          console.log("Starting saveProject function");
          let savedData = {
            layers: {},
            currentLocationName: this.currentLocationName || "",
            currentLocationId: this.currentLocationId || null
          };

          for (const layerName in this.layers) {
            if (!this.layers[layerName]) continue;

            console.log(`Processing layer: ${layerName}`);
            const layer = this.layers[layerName];

            const layerInfo = {
              color: this.layerColors[layerName] || "#3388ff",
              features: [],
              properties: {}
            };

            // Save layer properties including QD analysis flag
            if (layer.properties) {
              layerInfo.properties = {...layer.properties};
              console.log(`Saving layer ${layerName} properties:`, layerInfo.properties);
            }

            layer.eachLayer(function(l) {
              if (l.toGeoJSON) {
                const feature = l.toGeoJSON();

                feature.properties = feature.properties || {};
                feature.properties.layerName = layerName;

                if (l.options) {
                  feature.properties.style = {
                    color: l.options.color,
                    fillColor: l.options.fillColor,
                    weight: l.options.weight,
                    opacity: l.options.opacity,
                    fillOpacity: l.options.fillOpacity
                  };
                }

                if (l._popup) {
                  feature.properties.popupContent = l._popup._content;
                }

                layerInfo.features.push(feature);
              }
            });

            savedData.layers[layerName] = layerInfo;
          }

          localStorage.setItem('qdproProject', JSON.stringify(savedData));
          console.log("Project saved to localStorage:", savedData);

          sessionStorage.setItem('qdproProject', JSON.stringify(savedData));

          this.saveToServer(savedData);

          return true;
        } catch (error) {
          console.error("Error in saveProject:", error);
          alert("Error saving project: " + error.message);
          return false;
        }
      },

      saveToServer: function(data) {
        const features = [];

        for (const layerName in data.layers) {
          const layerData = data.layers[layerName];
          layerData.features.forEach(feature => {
            feature.layerName = layerName;
            features.push(feature);
          });
        }

        fetch('/api/save-layers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            features: features,
            layer_name: "all_layers",
            location_id: data.currentLocationId || null
          })
        })
        .then(response => response.json())
        .then(data => {
          console.log("Project saved successfully to server:", data);
        })
        .catch(error => {
          console.error("Error saving project to server:", error);
        });
      },

      loadProject: async function() {
        try {
          console.log("Starting loadProject function");

          const urlParams = new URLSearchParams(window.location.search);
          const locationId = urlParams.get('location_id');
          if (locationId) {
            await this.loadLocation(locationId);
            return;
          }

          const savedProject = localStorage.getItem('qdproProject');
          if (!savedProject) {
            console.log("No saved project found in localStorage");
            return false;
          }

          console.log("Found saved project in localStorage");
          let projectData;

          try {
            projectData = JSON.parse(savedProject);
            console.log("Parsed project data:", projectData);
          } catch (e) {
            console.error("Failed to parse saved project:", e);
            return false;
          }

          this.clearLayers();

          if (projectData.currentLocationName) {
            this.currentLocationName = projectData.currentLocationName;
            updateLocationDisplay(projectData.currentLocationName);
          }

          if (projectData.currentLocationId) {
            this.currentLocationId = projectData.currentLocationId;
          }

          for (const layerName in projectData.layers) {
            const layerData = projectData.layers[layerName];
            console.log(`Processing saved layer: ${layerName}`, layerData);

            const layer = L.featureGroup();

            // Restore layer properties
            if (layerData.properties) {
              layer.properties = {...layerData.properties};
              console.log(`Restored layer ${layerName} properties:`, layer.properties);
            }

            if (layerData.color) {
              this.layerColors[layerName] = layerData.color;
            }

            if (layerData.features && layerData.features.length > 0) {
              layerData.features.forEach(feature => {
                let style = {};
                if (feature.properties && feature.properties.style) {
                  style = feature.properties.style;
                } else {
                  style = {
                    color: this.layerColors[layerName] || "#3388ff",
                    fillColor: this.layerColors[layerName] || "#3388ff",
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 0.2
                  };
                }

                const geoJSONLayer = L.geoJSON(feature, {
                  style: style,
                  onEachFeature: (feature, layer) => {
                    if (feature.properties && feature.properties.popupContent) {
                      layer.bindPopup(feature.properties.popupContent);
                    }

                    this.addLayerClickHandlers(layer);
                  }
                });

                geoJSONLayer.eachLayer(l => {
                  layer.addLayer(l);
                });
              });
            }

            layer.addTo(this.map);
            this.layers[layerName] = layer;
          }

          this.updateLayerToggle();
          console.log("Project loaded successfully");
          return true;
        } catch (error) {
          console.error("Error loading project:", error);
          return false;
        }
      },
      clearLayers: function(clearBaseLayersToo = false) {
        // Safely check if map exists
        if (!this.map) {
          console.warn("Cannot clear layers: map is not initialized");
          return;
        }

        // Remove all layers from the map
        if (this.layers) {
          Object.values(this.layers).forEach(layer => {
            if (layer && this.map.hasLayer(layer)) {
              this.map.removeLayer(layer);
            }
          });
        }

        // Reset layers object
        this.layers = {};

        // Create a default layer
        const defaultLayer = L.featureGroup().addTo(this.map);
        this.layers['Default'] = defaultLayer;
        this.activeLayer = defaultLayer;

        // Update UI
        this.updateDrawToLayerSelect();
      },
      openFeaturePropertiesModal: function(layer) {
        const properties = layer.feature ? layer.feature.properties : {};

        // Create modal for editing properties
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'featurePropertiesModal';
        modal.style = 'display: block; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);';

        let modalContent = `
          <div id="featurePropertiesModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px;">
              <span style="float: right; cursor: pointer; font-size: 28px;" onclick="document.getElementById('featurePropertiesModal').style.display='none'">&times;</span>
              <h2>Edit Feature Properties</h2>
              <form id="featurePropertiesForm">
                <div style="margin-bottom: 10px;">
                  <label for="name">Display Name:</label>
                  <input type="text" id="name" name="name" style="width: 100%; padding: 5px;">
                </div>
                <div style="margin-bottom: 10px;">
                  <label>
                    <input type="checkbox" id="is_facility" name="is_facility">
                    Facility
                  </label>
                </div>
                <div style="margin-bottom: 10px;">
                  <label>
                    <input type="checkbox" id="has_explosive" name="has_explosive">
                    Contains Explosives (NEW)
                  </label>
                </div>
                <div id="newSection" style="margin-bottom: 10px; display: none;">
                  <label for="net_explosive_weight">Net Explosive Weight (lb):</label>
                  <input type="number" id="net_explosive_weight" name="net_explosive_weight" min="0" style="width: 100%; padding: 5px;">
                </div>
                <div style="margin-bottom: 10px;">
                  <label for="type">Facility Type:</label>
                  <select id="type" name="type" style="width: 100%; padding: 5px;">
                    <option value="Facility">Facility</option>
                    <option value="Storage">Storage</option>
                    <option value="Administrative">Administrative</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div style="margin-bottom: 10px;">
                  <label for="description">Description:</label>
                  <textarea id="description" name="description" style="width: 100%; padding: 5px; height: 60px;"></textarea>
                </div>
                <button type="submit" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; cursor: pointer;">Save</button>
                <button type="button" id="closeFeaturePropertiesBtn" style="padding: 8px 16px; margin-left: 10px;">Cancel</button>
              </form>
            </div>
          </div>/div>
              <div style="margin-bottom: 10px;">
                <label for="netExplosiveWeight">Net Explosive Weight (lbs):</label>
                <input type="number" id="netExplosiveWeight" value="${properties.net_explosive_weight || ''}" style="width: 100%; padding: 5px;">
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button type="button" id="savePropertiesBtn" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; cursor: pointer;">
                  Save
                </button>
                <button type="button" id="cancelPropertiesBtn" style="padding: 10px 15px; border: 1px solid #ddd; cursor: pointer;">
                  Cancel
                </button>
              </div>
            </form>
          </div>
        `;

        modal.innerHTML = modalContent;
        document.body.appendChild(modal);

        // Store reference to the layer
        const self = this;

        // Add event listeners
        document.getElementById('savePropertiesBtn').addEventListener('click', function() {
          // Get values from form
          const displayName = document.getElementById('displayName').value;
          const isNew = document.getElementById('newExplosiveFacility').checked;
          const type = document.getElementById('facilityType').value;
          const netExplosiveWeight = document.getElementById('netExplosiveWeight').value;

          // Ensure layer.feature and properties exist
          if (!layer.feature) {
            layer.feature = { properties: {} };
          }
          if (!layer.feature.properties) {
            layer.feature.properties = {};
          }

          // Update properties
          layer.feature.properties.displayName = displayName;
          layer.feature.properties.new = isNew;
          layer.feature.properties.type = type;
          layer.feature.properties.net_explosive_weight = netExplosiveWeight ? parseFloat(netExplosiveWeight) : null;

          // Close modal
          document.body.removeChild(modal);

          // Update popup if one exists
          if (layer.getPopup()) {
            const popupContent = `
              <div>
                <h3>${displayName || 'Unnamed Feature'}</h3>
                <p>Type: ${type || 'Unknown'}</p>
                ${netExplosiveWeight ? `<p>NEW: ${netExplosiveWeight} lbs</p>` : ''}
                <button class="edit-properties-btn">Edit Properties</button>
              </div>
            `;
            layer.setPopupContent(popupContent);

            // Add click handler to the edit button in popup
            setTimeout(() => {
              const editBtn = document.querySelector('.edit-properties-btn');
              if (editBtn) {
                editBtn.addEventListener('click', function() {
                  self.openFeaturePropertiesModal(layer);
                });
              }
            }, 100);
          }
        });

        document.getElementById('cancelPropertiesBtn').addEventListener('click', function() {
          document.body.removeChild(modal);
        });
      },

      addLayerClickHandlers: function(layer) {
        // Add popup with properties
        const properties = layer.feature ? layer.feature.properties : {};
        const popupContent = `
          <div>
            <h3>${properties.name || 'Unnamed Feature'}</h3>
            <p>Type: ${properties.type || 'Unknown'}</p>
            ${properties.net_explosive_weight ? `<p>NEW: ${properties.net_explosive_weight} lbs</p>` : ''}
            <button class="edit-properties-btn">Edit Properties</button>
          </div>
        `;

        layer.bindPopup(popupContent);

        // Add click handler
        layer.on('popupopen', function() {
          setTimeout(() => {
            const editBtn = document.querySelector('.edit-properties-btn');
            if (editBtn) {
              editBtn.addEventListener('click', function() {
                openFeatureEditor(layer);
              });
            }
          }, 100);
        });

        layer.on({
          click: (e) => {
            console.log('Layer clicked:', e.latlng);
            // Store the clicked layer for potential editing
            window.lastClickedLayer = layer;
          }
        });
      },
      updateLayerToggle: function() {
        this.updateDrawToLayerSelect();
        this.updateLayersList();

        const layerNames = Object.keys(this.layers);
        if (layerNames.length > 0) {
          const selectElement = document.getElementById("drawToLayer");
          if (selectElement) {
            selectElement.value = layerNames[0];
            this.switchDrawToLayer();
          }
        }
        // Attempt to fit bounds after loading
        if (Object.keys(this.layers).length > 0) {
          try {
            let hasValidBounds = false;
            let bounds = L.latLngBounds([]);

            for (let layerName in this.layers) {
              const layer = this.layers[layerName];
              if (layer.getLayers().length > 0) {
                try {
                  const layerBounds = layer.getBounds();
                  if (layerBounds.isValid()) {
                    bounds.extend(layerBounds);
                    hasValidBounds = true;
                  }
                } catch (e) {
                  console.warn(`Layer ${layerName} has invalid bounds:`, e);
                }
              }
            }

            if (hasValidBounds) {
              this.map.fitBounds(bounds);
            } else {
              console.log("No valid bounds found, using default view");
            }
          } catch (e) {
            console.warn("Error fitting bounds:", e);
          }
        }
      },

      updateLayersList: function() {
        const layersList = document.getElementById("availableLayers");
        if (!layersList) return;

        // Clear the current list
        layersList.innerHTML = "";

        // Add each layer to the list
        for (const layerName in this.layers) {
          const layerItem = document.createElement("li");
          layerItem.style.padding = "8px 5px";
          layerItem.style.borderBottom = "1px solid #eee";
          layerItem.style.display = "flex";
          layerItem.style.alignItems = "center";

          // Create checkbox for toggling visibility
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = this.map.hasLayer(this.layers[layerName]);
          checkbox.style.marginRight = "10px";
          checkbox.dataset.layerName = layerName;

          // Toggle layer visibility when checkbox changes
          checkbox.addEventListener("change", (e) => {
            const layer = this.layers[e.target.dataset.layerName];
            if (e.target.checked) {
              if (!this.map.hasLayer(layer)) {
                this.map.addLayer(layer);
              }
            } else {
              if (this.map.hasLayer(layer)) {
                this.map.removeLayer(layer);
              }
            }
          });

          // Create label with layer name
          const label = document.createElement("span");
          label.textContent = layerName;
          label.style.flexGrow = "1";

          // Create edit button
          const editButton = document.createElement("button");
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.style.marginLeft = "5px";
          editButton.style.border = "none";
          editButton.style.background = "transparent";
          editButton.style.cursor = "pointer";
          editButton.title = "Edit layer properties";
          editButton.dataset.layerName = layerName;
          editButton.addEventListener("click", (e) => {
            this.showLayerEditModal(e.target.dataset.layerName || e.target.parentElement.dataset.layerName);
          });

          // Add elements to the layer item
          layerItem.appendChild(checkbox);
          layerItem.appendChild(label);
          layerItem.appendChild(editButton);

          // Add the layer item to the list
          layersList.appendChild(layerItem);
        }
      },
      getLayerNameByObject: function(layerObj) {
        for (let name in this.layers) {
          if (this.layers[name] === layerObj) {
            return name;
          }
        }
        return null;
      },

      // Layer editing functionality
      currentEditingLayer: null,

      showLayerEditModal: function(layerName) {
        if (!layerName || !this.layers[layerName]) return;

        this.currentEditingLayer = layerName;
        const layer = this.layers[layerName];

        // Fill in the form with current values
        document.getElementById("editLayerName").value = layerName;

        // Set the QD analysis dropdown based on layer properties
        const isQDLayer = layer.properties && layer.properties.isQDAnalyzed;
        document.getElementById("isQDLayer").value = isQDLayer ? "true" : "false";

        // Set the layer color
        const layerColor = this.layerColors[layerName] || "#3388ff";
        document.getElementById("layerColor").value = layerColor;

        // Show the modal
        document.getElementById("layerEditModal").classList.add("visible");
      },

      closeLayerEditModal: function() {
        document.getElementById("layerEditModal").classList.remove("visible");
        this.currentEditingLayer = null;
      },

      saveLayerEdits: function() {
        if (!this.currentEditingLayer) return;

        const oldLayerName = this.currentEditingLayer;
        const newLayerName = document.getElementById("editLayerName").value.trim();
        const isQDLayer = document.getElementById("isQDLayer").value === "true";
        const layerColor = document.getElementById("layerColor").value;

        // Update layer properties
        const layer = this.layers[oldLayerName];

        // Create properties object if it doesn't exist
        if (!layer.properties) {
          layer.properties = {};
        }

        // Set QD analysis flag
        layer.properties.isQDAnalyzed = isQDLayer;

        console.log(`Layer ${oldLayerName} QD status set to: ${isQDLayer}`);

        // Update layer color
        this.layerColors[oldLayerName] = layerColor;

        // Apply color to all features in the layer if they support styling
        layer.eachLayer(feature => {
          if (feature.setStyle) {
            feature.setStyle({
              color: layerColor,
              fillColor: layerColor,
              weight: 3,
              opacity: 1,
              fillOpacity: 0.2
            });
          }
        });

        // Rename the layer if the name has changed
        if (newLayerName && newLayerName !== oldLayerName) {
          // Store the layer object
          const layerObj = this.layers[oldLayerName];

          // Delete the old entry
          delete this.layers[oldLayerName];

          // Add with new name
          this.layers[newLayerName] = layerObj;

          // Move the color
          this.layerColors[newLayerName] = this.layerColors[oldLayerName];
          if (oldLayerName !== newLayerName) {
            delete this.layerColors[oldLayerName];
          }

          // Update active layer if needed
          if (this.activeLayer === layerObj) {
            this.updateDrawToLayerSelect();
          }
        }

        // Update UI elements
        this.updateLayersList();
        this.updateDrawToLayerSelect();

        // Save project changes to ensure persistence
        this.saveProject();

        // Close the modal
        this.closeLayerEditModal();
      },
      loadLocation: async function(locationId) {
        try {
          const response = await fetch(`/api/load-layers?location_id=${locationId}`);
          const data = await response.json();
          if (data.name) {
            this.currentLocationName = data.name;
            updateLocationDisplay(data.name);
            this.currentLocationId = locationId;
          }

          this.clearLayers();
          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;
          this.updateDrawToLayerSelect();
          await this.loadProject();
        } catch (error) {
          console.error("Error loading location:", error);
          alert(`Failed to load location with ID ${locationId}`);
        }
      },
      getRandomColor: function() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      },
      addLayer: function(layerName, layerColor) {
        const newLayer = L.featureGroup().addTo(this.map);
        this.layers[layerName] = newLayer;
        this.layerColors[layerName] = layerColor;
        return newLayer;
      },
      analyzeLocation: async function() {
        if (!this.currentLocationId) {
          alert("Please open a location before running analysis");
          return;
        }

        // Get all selectable features from all layers
        const allFeatures = [];
        Object.entries(this.layers).forEach(([layerName, layer]) => {
          layer.eachLayer(l => {
            if (l.toGeoJSON) {
              const feature = l.toGeoJSON();
              // Make sure to preserve properties
              if (l.feature && l.feature.properties) {
                feature.properties = {...feature.properties, ...l.feature.properties};
              }
              // Add layer name and ID for reference
              feature.properties.layerName = layerName;
              feature.properties.featureId = l._leaflet_id || Math.random().toString(36).substr(2, 9);
              // Add a human-readable name for display
              feature.properties.displayName = feature.properties.name || feature.properties.facility_name || 
                                               (feature.properties.type ? `${feature.properties.type} Feature` : `Feature ${String(feature.properties.featureId).slice(-4)}`);
              allFeatures.push(feature);
            }
          });
        });

        if (allFeatures.length === 0) {
          alert("No shapes to analyze. Please draw some shapes first.");
          return;
        }

        // Create a selection modal for choosing features to analyze
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'analysisSelectionModal';
        modal.style = 'display: block; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);';

        let modalContent = `
          <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px;">
            <h2>Select Features for Analysis</h2>
            <div style="margin-bottom: 10px;">
              <button id="selectAllFeatures" style="margin-right: 10px;">Select All</button>
              <button id="deselectAllFeatures">Deselect All</button>
            </div>
            <div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-bottom: 15px;">
        `;

        // Group features by layer for better organization
        const featuresByLayer = {};
        allFeatures.forEach(feature => {
          const layerName = feature.properties.layerName;
          if (!featuresByLayer[layerName]) {
            featuresByLayer[layerName] = [];
          }
          featuresByLayer[layerName].push(feature);
        });

        // Add feature selection checkboxes grouped by layer
        Object.entries(featuresByLayer).forEach(([layerName, features]) => {
          modalContent += `<div style="margin-bottom: 10px;"><strong>${layerName}</strong></div>`;

          features.forEach(feature => {
            const featureId = feature.properties.featureId;
            const isExplosiveFacility = feature.properties.net_explosive_weight || 
                                        feature.properties.new || 
                                        feature.properties.type === 'Facility' || 
                                        feature.properties.type === 'Bunker';

            modalContent += `
              <div style="margin-left: 20px; margin-bottom: 5px;">
                <input type="checkbox" id="feature-${featureId}" 
                       data-feature-id="${featureId}" 
                       ${isExplosiveFacility ? 'checked' : ''}>
                <label for="feature-${featureId}">
                  ${feature.properties.displayName || 'Unnamed Feature'}
                  ${isExplosiveFacility ? ' (Explosive Facility)' : ''}
                </label>
              </div>
            `;
          });
        });

        modalContent += `
            </div>
            <div>
              <button id="runAnalysisBtn" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; cursor: pointer; margin-right: 10px;">
                Run Analysis
              </button>
              <button id="cancelAnalysisBtn" style="padding: 10px 15px; border: 1px solid #ddd; cursor: pointer;">
                Cancel
              </button>
            </div>
          </div>
        `;

        modal.innerHTML = modalContent;
        document.body.appendChild(modal);

        // Add event listeners to buttons
        document.getElementById('selectAllFeatures').addEventListener('click', () => {
          document.querySelectorAll('#analysisSelectionModal input[type="checkbox"]').forEach(cb => {
            cb.checked = true;
          });
        });

        document.getElementById('deselectAllFeatures').addEventListener('click', () => {
          document.querySelectorAll('#analysisSelectionModal input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
          });
        });

        document.getElementById('cancelAnalysisBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
        });

        const self = this;
        document.getElementById('runAnalysisBtn').addEventListener('click', async function() {
          // Get selected features
          const selectedCheckboxes = Array.from(
            document.querySelectorAll('#analysisSelectionModal input[type="checkbox"]:checked')
          );

          console.log("Selected checkboxes:", selectedCheckboxes.length);

          // Get the feature IDs from the checkboxes
          const selectedFeatureIds = selectedCheckboxes.map(cb => cb.getAttribute('data-feature-id'));
          console.log("Selected feature IDs:", selectedFeatureIds);

          // Convert all IDs to strings for consistent comparison
          const selectedFeatures = allFeatures.filter(f => 
            selectedFeatureIds.includes(String(f.properties.featureId))
          );

          console.log("Selected features after filtering:", selectedFeatures.length);
          console.log("All features available:", allFeatures.length);

          if (selectedFeatures.length === 0) {
            alert("Please select at least one feature to analyze.");
            return;
          }

          // Remove modal
          document.body.removeChild(modal);

          try {
            // Show loading indicator
            setStatusMessage("Running QD analysis...", "info");

            // Call the backend API
            const response = await fetch("/api/analyze-location", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                location_id: self.currentLocationId,
                features: selectedFeatures
              })
            });

            if (!response.ok) {
              throw new Error(`Analysis failed: ${response.statusText}`);
            }

            const result = await response.json();
            console.log("Analysis results:", result);

            // Display results on the map
            self.displayAnalysisResults(result);

            // Update status
            setStatusMessage(`Analysis complete: ${result.total_facilities} facilities analyzed, ${result.total_violations} violations found`, "success");
          } catch (error) {
            console.error("Error during analysis:", error);
            setStatusMessage(`Analysis failed: ${error.message}`, "error");
          }
        });
      },
      displayAnalysisResults: function(analysis) {
        // Clear any existing analysis layers
        if (this.analysisLayer) {
          this.map.removeLayer(this.analysisLayer);
        }

        // Create a new layer for analysis results
        this.analysisLayer = L.featureGroup().addTo(this.map);

        // Check if facilities data exists and is valid
        if (!analysis || !analysis.facilities_analyzed || !Array.isArray(analysis.facilities_analyzed)) {
          console.warn("No valid facilities to analyze in the analysis results");
          // Create a minimal summary panel to show the issue
          this.showAnalysisSummary(analysis || {total_facilities: 0, total_violations: 0, timestamp: new Date().toISOString()});
          return;
        }

        // Track if we've added any valid features to determine if bounds fitting is possible
        let hasValidFeatures = false;

        // Add QD rings to the map
        analysis.facilities_analyzed.forEach(facility => {
          // Validate facility coordinates
          const facilityLat = facility.facility_latitude || 0;
          const facilityLng = facility.facility_longitude || 0;

          if (!isFinite(facilityLat) || !isFinite(facilityLng)) {
            console.warn(`Invalid facility coordinates for ${facility.facility_name || 'unnamed facility'}`);
            return; // Skip this facility
          }

          hasValidFeatures = true;

          // Add a marker for the facility location
          const facilityMarker = L.marker([facilityLat, facilityLng], {
            icon: L.divIcon({
              className: 'facility-icon',
              html: `<div style="background-color: red; border-radius: 50%; width: 12px; height: 12px; border: 2px solid white;"></div>`,
              iconSize: [16, 16],
              iconAnchor: [8, 8]
            })
          }).bindPopup(`<div class="analysis-popup">
  <h3>${facility.facility_name || 'Unnamed Facility'}</h3>
  <p><strong>NEW:</strong> ${facility.net_explosive_weight_display || 'N/A'} ${facility.unit_display || ''}</p>
  <p><strong>Safe Distance:</strong> ${facility.safe_distance || 'N/A'} ft</p>
  <p><strong>Analysis Status:</strong> ${facility.violations &&facility.violations.length ? facility.violations.length + ' violations found' : 'No violations'}</p<p><strong>Standard:</strong> ${facility.k_factor_type || 'Standard'} (K=${facility.k_factor_value || 'N/A`)
  <button class="close-btn" onclick="QDPro.closeAnalysisPopup()">Close</button>
</div>`)            .addTo(this.analysisLayer);

          // Add QD rings if available
          if (facility.qd_rings && Array.isArray(facility.qd_rings) && facility.qd_rings.length > 0) {
            facility.qd_rings.forEach(ring => {
              try {
                // Skip invalid GeoJSON
                if (!ring || !ring.type || !ring.coordinates) {
                  return;
                }

                // Create a style based on the QD type
                let style = {
                  fillColor: '#ff3300',
                  color: '#ff0000',
                  weight: 2,
                  opacity: 0.8,
                  fillOpacity: 0.2
                };

                // Different colors for different QD types
                if (ring.properties && ring.properties.qd_type) {
                  switch(ring.properties.qd_type) {
                    case 'IBD':
                      style.fillColor = '#ff3300';
                      style.color = '#ff0000';
                      break;
                    case 'PTRD':
                      style.fillColor = '#ff9900';
                      style.color = '#cc7700';
                      break;
                    case 'ILD':
                      style.fillColor = '#ffcc00';
                      style.color = '#cc9900';
                      break;
                    case 'IMD':
                      style.fillColor = '#33cc33';
                      style.color = '#009900';
                      break;
                    case 'FRAG':
                      style.fillColor = '#9900cc';
                      style.color = '#660099';
                      break;
                  }
                }

                // Create the GeoJSON layer
                const ringLayer = L.geoJSON(ring, {
                  style: style
                }).addTo(this.analysisLayer);

                // Add a popup with information
                if (ring.properties) {
                  ringLayer.bindPopup(`
                    <div class="qd-ring-popup">
                      <h4>${ring.properties.label || 'QD Ring'}</h4>
                      <p>${ring.properties.description || ''}</p>
                      ${ring.properties.standard ? `<p><small>${ring.properties.standard}</small></p>` : ''}
                    </div>
                  `);
                }
              } catch (err) {
                console.error("Error adding QD ring:", err);
              }
            });
          }

          // Add violations if any
          if (facility.violations && Array.isArray(facility.violations) && facility.violations.length > 0) {
            facility.violations.forEach(violation => {
              try {
                // Validate violation data
                if (!violation || !violation.feature_id) {
                  return;
                }

                // Iterate through all layers to find the matching feature
                for (const layerName in this.layers) {
                  const layerGroup = this.layers[layerName];
                  layerGroup.eachLayer(layer => {
                    if (layer.feature && (layer.feature.id === violation.feature_id || 
                        (layer.feature.properties && layer.feature.properties.id === violation.feature_id))) {
                      // Highlight the violated feature if it has styling capabilities
                      if (typeof layer.setStyle === 'function') {
                        layer.setStyle({
                          color: '#ff0000',
                          weight: 3,
                          fillColor: '#ff9999',
                          fillOpacity: 0.5
                        });
                      }

                      // Add a popup with violation details
                      layer.bindPopup(`
                        <div class="violation-popup">
                          <h4>QD Violation</h4>
                          <p><strong>Feature:</strong> ${violation.feature_name || 'Unknown Feature'}</p>
                          <p><strong>Current Distance:</strong> ${violation.distance || 'N/A'} ft</p>
                          <p><strong>Required Distance:</strong> ${violation.required || violation.required_distance || 'N/A'} ft</p>
                          <p><strong>Deficiency:</strong> ${violation.deficiency || 'N/A'} ft ${violation.percent_deficient ? `(${violation.percent_deficient}%)` : ''}</p>
                          <p><small>${violation.standard_reference || ''}</small></p>
                        </div>
                      `);

                      // Add a violation marker
                      const violationIcon = L.divIcon({
                        className: 'violation-icon',
                        html: '<div><i class="fas fa-exclamation-triangle"></i></div>',
                        iconSize: [24, 24]
                      });

                      // Get the centroid of the violated feature
                      let violationPoint;
                      if (typeof layer.getLatLng === 'function') {
                        violationPoint = layer.getLatLng();
                      } else if (typeof layer.getBounds === 'function') {
                        try {
                          violationPoint = layer.getBounds().getCenter();
                        } catch (e) {
                          console.warn("Could not get bounds center:", e);
                          return;
                        }
                      } else {
                        return;
                      }

                      const violationMarker = L.marker(violationPoint, {
                        icon: violationIcon
                      }).addTo(this.analysisLayer);

                      violationMarker.bindPopup(`
                        <div class="violation-popup">
                          <h4>QD Violation</h4>
                          <p><strong>Feature:</strong> ${violation.feature_name || 'Unknown Feature'}</p>
                          <p><strong>Required Distance:</strong> ${violation.required || violation.required_distance || 'N/A'} ft</p>
                          <p><strong>Current Distance:</strong> ${violation.distance || 'N/A'} ft</p>
                          <p><strong>Deficiency:</strong> ${violation.deficiency || 'N/A'} ft ${violation.percent_deficient ? `(${violation.percent_deficient}%)` : ''}</p>
                        </div>
                      `);
                    }
                  });
                }
              } catch (err) {
                console.error("Error processing violation:", err);
              }
            });
          }
        });

        // Create a summary panel and display it
        this.showAnalysisSummary(analysis);

        // Zoom to fit all analysis features only if we have valid features
        if (hasValidFeatures) {
          try {
            // First check if the layer has valid bounds
            const layerBounds = this.analysisLayer.getBounds();
            if (layerBounds && layerBounds.isValid()) {
              this.map.fitBounds(layerBounds);
            } else {
              console.warn("Analysis layer has invalid bounds, cannot fit");
            }
          } catch (e) {
            console.error("Could not fit bounds:", e);
            // If we can't fit bounds, at least center on the first facility
            if (analysis.facilities_analyzed && analysis.facilities_analyzed.length > 0) {
              const firstFacility = analysis.facilities_analyzed[0];
              if (firstFacility.facility_latitude && firstFacility.facility_longitude) {
                this.map.setView([firstFacility.facility_latitude, firstFacility.facility_longitude], 15);
              }
            }
          }
        }
      },

      // Helper method to show analysis summary panel
      showAnalysisSummary: function(analysis) {
        // Create a summary panel for the analysis
        const summaryPanel = document.createElement('div');
        summaryPanel.className = 'analysis-summary-panel';
        summaryPanel.innerHTML = `
          <h3>Analysis Results</h3>
          <p><strong>Total Facilities:</strong> ${analysis.total_facilities || 0}</p>
          <p><strong>Total Violations:</strong> ${analysis.total_violations || 0}</p>
          <p><strong>Analysis Timestamp:</strong> ${new Date(analysis.timestamp || Date.now()).toLocaleString()}</p>
          <button id="closeAnalysisBtn" class="close-btn">Close Analysis</button>
        `;

        document.body.appendChild(summaryPanel);

        // Handle close button
        document.getElementById('closeAnalysisBtn').addEventListener('click', () => {
          if (this.analysisLayer) {
            this.map.removeLayer(this.analysisLayer);
            this.analysisLayer = null;
          }
          document.body.removeChild(summaryPanel);
        });
      },
      showAnalysisReportModal: function(analysis) {
        // Create a modal for the analysis report
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'analysisReportModal';
        modal.style = 'display: block; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);';

        let modalContent = `
          <div style="background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 800px; max-height: 85vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
              <h2>QD Analysis Report</h2>
              <div>
                <button id="exportPdfBtn" style="background-color: #4CAF50; color: white; padding: 5px 10px; margin-right: 10px; border: none; cursor: pointer;">
                  Export PDF
                </button>
                <button id="closeReportBtn" style="background-color: #f44336; color: white; padding: 5px 10px; border: none; cursor: pointer;">
                  Close
                </button>
              </div>
            </div>

            <div style="padding: 10px; border: 1px solid #ddd; margin-bottom: 15px; background-color: #f9f9f9;">
              <h3>Summary</h3>
              <p><strong>Location:</strong> ${this.currentLocationName || 'Current Location'}</p>
              <p><strong>Total Facilities Analyzed:</strong> ${analysis.total_facilities}</p>
              <p><strong>Total Violations Found:</strong> ${analysis.total_violations}</p>
              <p><strong>Analysis Date:</strong> ${new Date().toLocaleString()}</p>
            </div>
        `;

        // Detailed facility analysis
        if (analysis.facilities_analyzed && analysis.facilities_analyzed.length > 0) {
          modalContent += `<h3>Facilities Analyzed</h3>`;

          analysis.facilities_analyzed.forEach(facility => {
            const hasViolations = facility.violations && facility.violations.length > 0;

            modalContent += `
              <div style="padding: 10px; border: 1px solid ${hasViolations ? '#f44336' : '#ddd'}; 
                          margin-bottom: 15px; background-color: ${hasViolations ? '#fff8f8' : '#fff'};">
                <h4 style="color: ${hasViolations ? '#f44336' : '#333'};">
                  ${facility.facility_name || 'Unnamed Facility'} 
                  ${hasViolations ? ' <span style="color: #f44336;">(VIOLATIONS FOUND)</span>' : ''}
                </h4>
                <div style="display: flex; flex-wrap: wrap;">
                  <div style="flex: 1; min-width: 250px; margin-right: 15px;">
                    <p><strong>Type:</strong> ${facility.facility_type || 'Bunker'}</p>
                    <p><strong>Net Explosive Weight:</strong> ${facility.net_explosive_weight} lbs</p>
                    <p><strong>Required Safety Distance:</strong> ${facility.safe_distance} ft</p>
                  </div>
                  <div style="flex: 1; min-width: 250px;">
                    <p><strong>Location:</strong> ${facility.facility_latitude ? `${facility.facility_latitude.toFixed(6)}, ${facility.facility_longitude.toFixed(6)}` : 'Unknown'}</p>
                    <p><strong>Rules Applied:</strong> ${facility.rules_applied || 'Standard DoD 6055.09-M'}</p>
                  </div>
                </div>
            `;

            // Violation details if any
            if (hasViolations) {
              modalContent += `
                <div style="margin-top: 10px; padding: 10px; background-color: #fff0f0; border-left: 3px solid #f44336;">
                  <h5 style="color: #f44336; margin-top: 0;">Safety Violations</h5>
                  <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                      <tr style="background-color: #f8f8f8;">
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Feature</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Actual Distance (ft)</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Required Distance (ft)</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Shortfall (ft)</th>
                      </tr>
                    </thead>
                    <tbody>
              `;

              facility.violations.forEach(violation => {
                const shortfall = Math.round(violation.required_distance - violation.distance);
                modalContent += `
                  <tr>
                    <td style="padding: 8px; text-align: left; border: 1px solid #ddd;">${violation.feature_name}</td>
                    <td style="padding: 8px; text-align: left; border: 1px solid #ddd;">${Math.round(violation.distance)}</td>
                    <td style="padding: 8px; text-align: left; border: 1px solid #ddd;">${Math.round(violation.required_distance)}</td>
                    <td style="padding: 8px; text-align: left; border: 1px solid #ddd; color: #f44336; font-weight: bold;">${shortfall}</td>
                  </tr>
                `;
              });

              modalContent += `
                    </tbody>
                  </table>
                </div>
              `;
            } else {
              modalContent += `
                <div style="margin-top: 10px; padding: 10px; background-color: #f0fff0; border-left: 3px solid #4CAF50;">
                  <p style="color: #4CAF50; margin: 0;"><strong>✓ No safety violations detected for this facility</strong></p>
                </div>
              `;
            }

            modalContent += `</div>`;
          });
        }

        // Recommendations section
        modalContent += `
          <div style="padding: 10px; border: 1px solid #ddd; margin-top: 20px; background-color: #f9f9f9;">
            <h3>Recommendations</h3>
            <ul>
        `;

        if (analysis.total_violations > 0) {
          modalContent += `
            <li>Review all highlighted violations and assess the risk level for each.</li>
            <li>Consider relocating explosive materials to maintain proper safety distances.</li>
            <li>Implement administrative controls for areas that cannot be physically modified.</li>
            <li>Consult safety officer for waiver requirements where violations cannot be resolved.</li>
          `;
        } else {
          modalContent += `
            <li>All analyzed facilities meet safety distance requirements.</li>
            <li>Continue to monitor any new construction or changes to facility usage.</li>
          `;
        }

        modalContent += `
            </ul>
          </div>

          <div style="margin-top: 20px; font-size: 0.8em; text-align: center; color: #777;">
            <p>Generated by QDPro Analysis Engine • ${new Date().toLocaleDateString()}</p>
          </div>
        </div>
        `;

        modal.innerHTML = modalContent;
        document.body.appendChild(modal);

        // Add event listeners to buttons
        document.getElementById('closeReportBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
        });

        document.getElementById('exportPdfBtn').addEventListener('click', () => {
          // Use the exportPDF function if available, otherwise print
          if (typeof exportPDF === 'function') {
            exportPDF();
          } else {
            window.print();
          }
        });
      },
      closeAnalysisPopup: function() {
        this.analysisLayer.eachLayer(layer => {
          if (layer.closePopup) {
            layer.closePopup();
          }
        });
      }
    };

    function setStatusMessage(message, type) {
      const statusElement = document.getElementById('statusMessage');
      if (statusElement) {
        statusElement.textContent = message;
        statusElement.className = 'status-message ' + (type || 'info');
        statusElement.style.display = 'block';

        // Hide after 5 seconds
        setTimeout(() => {
          statusElement.style.display = 'none';
        }, 5000);
      } else {
        console.log(`Status: ${message} (${type})`);
      }
    }

    function clearAllLayers() {
      QDPro.clearLayers();
    }


    function showNewLocationModal() { QDPro.showNewLocationModal(); }
    function closeNewLocationModal() { QDPro.closeNewLocationModal(); }
    function createNewLocation() { QDPro.createNewLocation(); }
    function showSwitchLocationModal() { QDPro.showSwitchLocationModal(); }
    function closeSwitchLocationModal() { QDPro.closeSwitchLocationModal(); }
    function showAddLayerModal() { QDPro.showAddLayerModal(); }
    function closeAddLayerModal() { QDPro.closeAddLayerModal(); }
    function createNewLayer() { QDPro.createNewLayer(); }
    function saveProject() { QDPro.saveProject(); }
    function loadProject() { QDPro.loadProject(); }

    function showLayerEditModal(layerName) { QDPro.showLayerEditModal(layerName); }
    function closeLayerEditModal() { QDPro.closeLayerEditModal(); }
    function saveLayerEdits() { QDPro.saveLayerEdits(); }

    // Initialize status display
    document.getElementById('dbStatus').textContent = "No location loaded";

    // Load last used location if available
    (async function loadLastLocation() {
      const lastLocationId = localStorage.getItem('lastLocationId');
      if (lastLocationId) {
        try {
          console.log("Loading last used location:", lastLocationId);
          await QDPro.switchToLocation(parseInt(lastLocationId, 10));
          console.log("Last location loaded successfully");
        } catch (error) {
          console.error("Failed to load last location:", error);
          document.getElementById('dbStatus').textContent = "No location loaded";
        }
      }
    })();

    // Add database connection status check
    async function checkDatabaseConnection() {
      try {
        const response = await fetch('/api/db_status');
        if (response.ok) {
          // Only update if no location is currently displayed
          const currentStatus = document.getElementById('dbStatus').textContent;
          if (!currentStatus.includes("Location:")) {
            document.getElementById('dbStatus').textContent = "Database connection successful";
          }
        } else {
          document.getElementById('dbStatus').textContent = "Database connection failed";
        }
      } catch (e) {
        document.getElementById('dbStatus').textContent = "Database connection error";
      }
    }

    // Check database connection on page load
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(checkDatabaseConnection, 1000);
    });

    //Helper function to update location display
    function updateLocationDisplay(locationName) {
      document.getElementById('dbStatus').textContent = `Location: ${locationName}`;
    }

    function closeFeaturePropertiesModal() {
      document.getElementById('featurePropertiesModal').style.display = 'none';
    }

    document.addEventListener("DOMContentLoaded", () => QDPro.init());
  </script>
  <script src="/static/js/custom-modal.js"></script>
</body>
</html>