<!DOCTYPE html>
<html>
<head>
  <title>QDPro – Working Example with Persistence</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" crossorigin="anonymous"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js" crossorigin="anonymous"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; height: 100vh; overflow: hidden; }
    nav.main-toolbar {
      position: fixed; top: 0; left: 0; right: 0;
      height: 40px; background: #f1f1f1; border-bottom: 1px solid #ccc;
      display: flex; align-items: center; z-index: 3000; padding: 0 10px;
      white-space: nowrap;
    }
    .menu-item { padding: 0 15px; font-size: 14px; display: flex; align-items: center; cursor: pointer; position: relative; }

<style>
  /* Modal styles */
  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
  }
  
  .modal-content {
    background-color: #fefefe;
    margin: 10% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    border-radius: 5px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  
  .close-btn {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }
  
  .close-btn:hover {
    color: black;
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  .form-control {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box;
  }
  
  .btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  
  .btn-primary {
    background-color: #4CAF50;
    color: white;
  }
  
  .btn-default {
    background-color: #f1f1f1;
    color: #333;
  }
  
  .text-success {
    color: green;
  }
  
  .text-danger {
    color: red;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
  }
  
  th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }
  
  th {
    background-color: #f2f2f2;
  }
</style>

    .menu-item:hover { background: #e9ecef; }
    .menu-dropdown { display: none; position: fixed; background: white; min-width: 150px; border: 1px solid #ccc; border-radius: 4px; z-index: 3500; }
    .menu-dropdown-item { padding: 8px 12px; font-size: 14px; cursor: pointer; }
    .menu-dropdown-item:hover { background: #f0f0f0; }
    #dbStatus { margin-left: auto; }
    .toolbar { position: fixed; top: 40px; left: 0; right: 0; height: 40px; background: #fff; border-bottom: 1px solid #ccc; display: flex; align-items: center; z-index: 2900; padding: 0 10px; }
    .tool-group { display: flex; align-items: center; margin-right: 10px; }
    .tool-button { padding: 6px; margin: 0 2px; border: 1px solid transparent; border-radius: 3px; background: #fff; color: #666; cursor: pointer; display: flex; align-items: center; justify-content: center; min-width: 32px; height: 32px; }
    .tool-button:hover { background: #f0f0f0; border-color: #ccc; }
    .tool-button.active { background: #e6f2ff; border-color: #99ccff; color: #0066cc; }
    #map { position: fixed; top: 80px; left: 0; right: 0; bottom: 0; z-index: 1000; background: #eee; }
    .left-panel { position: fixed; top: 80px; left: 0; width: 300px; height: calc(100vh - 80px); background: white; border-right: 1px solid #ccc; transform: translateX(-300px); transition: transform 0.3s ease; z-index: 1500; display: flex; flex-direction: column; }
    .left-panel.visible { transform: translateX(0); }
    .panel-header { padding: 15px; background: #f8f9fa; border-bottom: 1px solid #ccc; font-weight: bold; }
    .panel-content { padding: 15px; flex-grow: 1; overflow-y: auto; }
    .base-layer-dropdown { position: fixed; background: white; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); z-index: 2800; display: none; }
    .modal-overlay { display: none; position: fixed; z-index: 4000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); align-items: center; justify-content: center; }
    .modal-overlay.visible { display: flex; }
    .modal-content { background: #fff; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; }
    .modal-content h2 { margin-bottom: 15px; }

<!-- QD Analysis Modal -->
<div id="qd-analysis-modal" class="modal">
  <div class="modal-content" style="width: 50%; max-width: 600px;">
    <span class="close-btn" onclick="document.getElementById('qd-analysis-modal').style.display='none'">&times;</span>
    <h2>QD Analysis</h2>
    <div class="form-group">
      <label for="analysis-feature">Feature to Analyze:</label>
      <select id="analysis-feature" class="form-control">
        <option value="">Select a feature...</option>
      </select>
    </div>
    <div class="form-group">
      <label for="analysis-quantity">Quantity (lbs):</label>
      <input type="number" id="analysis-quantity" class="form-control" value="100">
    </div>
    <div class="form-group">
      <label for="analysis-k-factor">K-Factor:</label>
      <select id="analysis-k-factor" class="form-control">
        <option value="40">DoD Standard (K40)</option>
        <option value="50">DoE Standard (K50)</option>
        <option value="44.4">NATO Standard (K44.4)</option>
        <option value="24">Public Traffic Route (K24)</option>
        <option value="18">Military Boundary (K18)</option>
      </select>
    </div>
    <div class="form-group">
      <label for="analysis-site-type">Site Type:</label>
      <select id="analysis-site-type" class="form-control">
        <option value="DOD">Department of Defense</option>
        <option value="DOE">Department of Energy</option>
        <option value="NATO">NATO Standard</option>
      </select>
    </div>
    <button class="btn btn-primary" onclick="QDPro.runQDAnalysis()">Run Analysis</button>
  </div>
</div>

<!-- Analysis Results Modal -->
<div id="analysis-results-modal" class="modal">
  <div class="modal-content" style="width: 70%; max-width: 800px;">
    <span class="close-btn" onclick="document.getElementById('analysis-results-modal').style.display='none'">&times;</span>
    <h2>Analysis Results</h2>
    <div id="analysis-summary" style="margin-bottom: 15px; padding: 10px; background-color: #f5f5f5;">
      <p><strong>Feature:</strong> <span id="analysis-feature-name"></span></p>
      <p><strong>Safe Distance:</strong> <span id="analysis-safe-distance"></span> feet</p>
      <p><strong>Quantity:</strong> <span id="analysis-quantity-display"></span> lbs</p>
      <p><strong>K-Factor:</strong> <span id="analysis-k-factor-display"></span></p>
    </div>
    
    <h3>Exposed Facilities</h3>
    <div style="max-height: 300px; overflow-y: auto;">
      <table id="analysis-results-table" class="table table-striped">
        <thead>
          <tr>
            <th>Name</th>
            <th>Distance (ft)</th>
            <th>Required (ft)</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="analysis-results-body">
          <!-- Results will be inserted here -->
        </tbody>
      </table>
    </div>
    
    <div style="margin-top: 20px;">
      <button class="btn btn-primary" onclick="QDPro.generateReport()">Generate Report</button>
      <button class="btn btn-default" onclick="QDPro.saveAnalysisLayer()">Save Analysis Layer</button>
    </div>
  </div>
</div>

<!-- Report Generation Modal -->
<div id="report-modal" class="modal">
  <div class="modal-content" style="width: 50%; max-width: 500px;">
    <span class="close-btn" onclick="document.getElementById('report-modal').style.display='none'">&times;</span>
    <h2>Generate Report</h2>
    <div class="form-group">
      <label for="report-title">Report Title:</label>
      <input type="text" id="report-title" class="form-control" value="QD Safety Analysis Report">
    </div>
    <div class="form-group">
      <label>
        <input type="checkbox" id="include-map" checked> Include Map Screenshot
      </label>
    </div>
    <button class="btn btn-primary" onclick="QDPro.createReport()">Create PDF Report</button>
  </div>
</div>

    .modal-content input, .modal-content select, .modal-content textarea { width: 100%; padding: 5px; margin-top: 5px; margin-bottom: 10px; }
    .modal-content button { margin: 5px; }
  </style>
</head>
<body>
  <nav class="main-toolbar">
    <div class="menu-item" onclick="toggleMenu(this, 'fileMenu')">File
      <div class="menu-dropdown" id="fileMenu">
        <div class="menu-dropdown-item" onclick="showNewLocationModal()">New Location</div>
        <div class="menu-dropdown-item" onclick="showSwitchLocationModal()">Switch Location</div>
        <div class="menu-dropdown-item" onclick="saveProject()">Save Project</div>
        <div class="menu-dropdown-item" onclick="loadProject()">Load Project</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'editMenu')">Edit
      <div class="menu-dropdown" id="editMenu">
        <div class="menu-dropdown-item">Cut</div>
        <div class="menu-dropdown-item">Copy</div>
        <div class="menu-dropdown-item">Paste</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'viewMenu')">View
      <div class="menu-dropdown" id="viewMenu">
        <div class="menu-dropdown-item">Layers</div>
        <div class="menu-dropdown-item">Base Maps</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'toolsMenu')">Tools
      <div class="menu-dropdown" id="toolsMenu">
        <div class="menu-dropdown-item">QD Calculator</div>
        <div class="menu-dropdown-item">Measure</div>
      </div>
    </div>
    <div class="menu-item" onclick="toggleMenu(this, 'helpMenu')">Help
      <div class="menu-dropdown" id="helpMenu">
        <div class="menu-dropdown-item">Documentation</div>
        <div class="menu-dropdown-item">About</div>
      </div>
    </div>
    <div id="dbStatus">No location selected</div>
  </nav>

  <div class="toolbar">
    <div class="tool-group">
      <button id="toggleLayersPanel" class="tool-button" title="Toggle Layers Panel"><i class="fas fa-bars"></i></button>
      <button id="baseLayerTool" class="tool-button" title="Base Layers"><i class="fas fa-layer-group"></i></button>
    </div>
    <div class="tool-group">
      <button id="zoomInBtn" class="tool-button" title="Zoom In"><i class="fas fa-search-plus"></i></button>
      <button id="zoomOutBtn" class="tool-button" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
    </div>
    <div class="tool-group">
      <button id="selectTool" class="tool-button" title="Select Features"><i class="fas fa-mouse-pointer"></i></button>
      <button id="panTool" class="tool-button active" title="Pan Map"><i class="fas fa-hand-paper"></i></button>
    </div>
    <div class="tool-group">
      <button id="drawMarker" class="tool-button" title="Add Point"><i class="fas fa-map-marker-alt"></i></button>
      <button id="drawPolygon" class="tool-button" title="Draw Polygon"><i class="fas fa-draw-polygon"></i></button>
      <button id="drawRectangle" class="tool-button" title="Draw Rectangle"><i class="fas fa-square"></i></button>
      <button id="drawCircle" class="tool-button" title="Draw Circle"><i class="fas fa-circle"></i></button>
      <button id="drawPolyline" class="tool-button" title="Draw Line"><i class="fas fa-minus"></i></button>
    </div>
  </div>

  <div class="left-panel" id="leftPanel">
    <div class="panel-header">Layers Panel</div>
    <div class="panel-content">
      <div class="layer-select-container">
        <label for="drawToLayer"><strong>Draw to Layer:</strong></label>
        <select id="drawToLayer" style="width: 100%; margin-top: 5px; padding: 5px;"></select>
        <button onclick="showAddLayerModal()" style="margin-top: 10px; width: 100%;">Add New Layer</button>
      </div>
      <div id="layerControl" style="margin-top:20px;"></div>
    </div>
  </div>

  <div id="baseLayerDropdown" class="base-layer-dropdown"></div>
  <div id="map"></div>

  <div id="newLocationModal" class="modal-overlay">
    <div class="modal-content">
      <h2>Create New Location</h2>
      <input type="text" id="newLocationName" placeholder="Enter location name"/>
      <div style="text-align:right;">
        <button onclick="closeNewLocationModal()" style="margin-right:10px;">Cancel</button>
        <button onclick="createNewLocation()">Create</button>
      </div>
    </div>
  </div>
  <div id="switchLocationModal" class="modal-overlay">
    <div class="modal-content">
      <h2>Switch Location</h2>
      <div id="locationList" style="margin:10px 0; max-height:200px; overflow-y:auto;"></div>
      <div style="text-align:right;">
        <button onclick="closeSwitchLocationModal()">Close</button>
      </div>
    </div>
  </div>
  <div id="addLayerModal" class="modal-overlay">
    <div class="modal-content">
      <h2>Add New Layer</h2>
      <input type="text" id="newLayerName" placeholder="Layer Name"/>
      <select id="newLayerType">
        <option value="facility">Facility</option>
        <option value="boundary">Boundary</option>
      </select>
      <div style="text-align:right;">
        <button onclick="closeAddLayerModal()" style="margin-right:10px;">Cancel</button>
        <button onclick="createNewLayer()">Create</button>
      </div>
    </div>
  </div>

  <script>
    window.toggleMenu = function(element, menuId) {
      const dropdown = document.getElementById(menuId);
      document.querySelectorAll(".menu-dropdown").forEach(dd => {
        if (dd.id !== menuId) { dd.style.display = "none"; dd.parentElement.classList.remove("active"); }
      });
      const isVisible = dropdown.style.display === "block";
      dropdown.style.display = isVisible ? "none" : "block";
      element.classList.toggle("active", !isVisible);
      if (!isVisible) {
        const rect = element.getBoundingClientRect();
        dropdown.style.top = rect.bottom + "px";
        dropdown.style.left = rect.left + "px";
      }
    };

    const QDPro = {
      map: null,
      layers: {},
      activeLayer: null,
      drawTools: {},
      baseLayers: {},
      currentBaseLayer: null,
      currentLocationId: null,
      currentLocationName: null,
      layerColors: {}, // Added to store layer colors
      init: async function() {
        console.log("Initializing QDPro...");

        this.currentLocationId = null;
        this.currentLocationName = null;

        this.map = L.map("map", { center: [39.8283, -98.5795], zoom: 4, zoomControl: false });
        this.baseLayers = {
          "OSM": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "© OpenStreetMap contributors" }),
          "Satellite": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", { attribution: "Tiles © Esri" }),
          "Topographic": L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", { attribution: "Map data: © OpenStreetMap contributors" })
        };
        this.currentBaseLayer = this.baseLayers.OSM;
        this.currentBaseLayer.addTo(this.map);
        this.activeLayer = L.featureGroup().addTo(this.map);
        this.layers["Default"] = this.activeLayer;
        this.setupDrawTools();
        const leftPanel = document.getElementById("leftPanel");
        const mapEl = document.getElementById("map");
        document.getElementById("toggleLayersPanel").addEventListener("click", () => {
          leftPanel.classList.toggle("visible");
          mapEl.style.left = leftPanel.classList.contains("visible") ? "300px" : "0";
          mapEl.style.width = leftPanel.classList.contains("visible") ? "calc(100% - 300px)" : "100%";
          this.map.invalidateSize();
        });
        document.getElementById("baseLayerTool").addEventListener("click", () => this.toggleBaseLayerDropdown());
        document.getElementById("zoomInBtn").addEventListener("click", () => this.map.zoomIn());
        document.getElementById("zoomOutBtn").addEventListener("click", () => this.map.zoomOut());
        document.getElementById("drawMarker").addEventListener("click", () => this.activateTool("marker", "drawMarker"));
        document.getElementById("drawPolygon").addEventListener("click", () => this.activateTool("polygon", "drawPolygon"));
        document.getElementById("drawRectangle").addEventListener("click", () => this.activateTool("rectangle", "drawRectangle"));
        document.getElementById("drawCircle").addEventListener("click", () => this.activateTool("circle", "drawCircle"));
        document.getElementById("drawPolyline").addEventListener("click", () => this.activateTool("polyline", "drawPolyline"));
        this.updateDrawToLayerSelect();

        document.getElementById("dbStatus").textContent = "No location selected";

        this.loadProject();
      },
      setupDrawTools: function() {
        const drawOptions = { shapeOptions: { color: "#3388ff" } };
        this.drawTools = {
          polygon: new L.Draw.Polygon(this.map, { allowIntersection: false, showArea: true, drawError: { color: "#e1e100", timeout: 1000 }, shapeOptions: { color: "#3388ff" } }),
          polyline: new L.Draw.Polyline(this.map, drawOptions),
          rectangle: new L.Draw.Rectangle(this.map, drawOptions),
          circle: new L.Draw.Circle(this.map, drawOptions),
          marker: new L.Draw.Marker(this.map)
        };
        this.map.on("draw:created", (e) => {
          const layer = e.layer;
          if (e.layerType === "polygon") {
            const coords = layer.getLatLngs()[0];
            if (coords.length > 0 && !coords[0].equals(coords[coords.length - 1])) {
              coords.push(coords[0]);
              layer.setLatLngs(coords);
            }
          }
          this.handleDrawCreated(e);
        });
        this.map.on("draw:edited", () => this.saveProject());
        this.map.on("draw:deleted", () => this.saveProject());
      },
      handleDrawCreated: function(e) {
        const layer = e.layer;
        const selectedLayer = document.getElementById("drawToLayer").value;

        if (!this.layers[selectedLayer]) {
          this.layers[selectedLayer] = L.featureGroup().addTo(this.map);
        }

        if (this.layerColors[selectedLayer]) {
          if (layer.setStyle) {
            layer.setStyle({
              color: this.layerColors[selectedLayer],
              fillColor: this.layerColors[selectedLayer],
              weight: 3,
              opacity: 1,
              fillOpacity: 0.2
            });
          }
        }

        this.layers[selectedLayer].addLayer(layer);
        this.addLayerClickHandlers(layer);

        this.saveProject();
        console.log("Project saved after creating new shape");
      },
      activateTool: function(toolName, buttonId) {
        this.deactivateAllTools();
        if (this.drawTools[toolName]) {
          this.drawTools[toolName].enable();
          document.getElementById(buttonId).classList.add("active");
        }
      },
      deactivateAllTools: function() {
        for (let tool in this.drawTools) this.drawTools[tool].disable();
        document.querySelectorAll(".tool-button").forEach(btn => btn.classList.remove("active"));
        document.getElementById("panTool").classList.add("active");
      },
      updateDrawToLayerSelect: function() {
        const sel = document.getElementById("drawToLayer");
        sel.innerHTML = "";

        for (let key in this.layers) {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = key;
          if (this.activeLayer === this.layers[key]) {
            opt.selected = true;
          }
          sel.appendChild(opt);
        }

        if (Object.keys(this.layers).length === 0) {
          const opt = document.createElement("option");
          opt.value = "Default";
          opt.textContent = "Default";
          opt.selected = true;
          sel.appendChild(opt);

          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;
        }

        sel.onchange = () => {
          this.switchDrawToLayer();
        };
      },
      switchDrawToLayer: function() {
        const layerName = document.getElementById("drawToLayer").value;
        if (layerName && this.layers[layerName]) {
          this.activeLayer = this.layers[layerName];

          if (layerName === "PES") {
            this.updateDrawStyles('red');
          } else if (layerName === "ES") {
            this.updateDrawStyles('green');
          } else {
            this.updateDrawStyles(null);
          }
        }
      },
      updateDrawStyles: function(color) {
        if (!color) {
          const drawOptions = { shapeOptions: { color: "#3388ff" } };
          for (let type in this.drawTools) {
            if (this.drawTools[type]) {
              this.drawTools[type].options.shapeOptions = drawOptions.shapeOptions;
            }
          }
          return;
        }

        const styleOptions = {
          shapeOptions: {
            color: color,
            fillColor: color,
            fillOpacity: 0.3
          }
        };

        for (let type in this.drawTools) {
          if (this.drawTools[type] && this.drawTools[type].options && this.drawTools[type].options.shapeOptions) {
            Object.assign(this.drawTools[type].options.shapeOptions, styleOptions.shapeOptions);
          }
        }
      },
      toggleBaseLayerDropdown: function() {
        const dropdown = document.getElementById("baseLayerDropdown");
        if (dropdown.style.display === "block") {
          dropdown.style.display = "none";
        } else {
          dropdown.innerHTML = "";
          for (let name in this.baseLayers) {
            const div = document.createElement("div");
            div.textContent = name;
            div.style.cursor = "pointer";
            div.style.padding = "5px";
            div.addEventListener("click", () => {
              this.switchBaseLayer(name);
              dropdown.style.display = "none";
              this.saveProject();
            });
            dropdown.appendChild(div);
          }
          const btn = document.getElementById("baseLayerTool");
          let rect = btn.getBoundingClientRect();
          dropdown.style.top = rect.bottom + "px";
          dropdown.style.left = rect.left + "px";
          dropdown.style.display = "block";
        }
      },
      switchBaseLayer: function(name) {
        if (this.currentBaseLayer) this.map.removeLayer(this.currentBaseLayer);
        this.currentBaseLayer = this.baseLayers[name];
        this.currentBaseLayer.addTo(this.map);
      },
      showAddLayerModal: function() { document.getElementById("addLayerModal").classList.add("visible"); },
      closeAddLayerModal: function() {
        document.getElementById("addLayerModal").classList.remove("visible");
        document.getElementById("newLayerName").value = "";
      },
      createNewLayer: function() {
        let layerName = document.getElementById("newLayerName").value.trim();
        let layerType = document.getElementById("newLayerType").value;
        if (!layerName) { alert("Enter a layer name"); return; }
        if (this.layers[layerName]) { alert(`Layer "${layerName}" exists`); return; }
        let newLayer = L.featureGroup().addTo(this.map);
        newLayer.properties = { type: layerType };
        this.layers[layerName] = newLayer;
        this.activeLayer = newLayer;
        this.updateDrawToLayerSelect();
        this.closeAddLayerModal();
        console.log(`Created layer: ${layerName}, type: ${layerType}`);
        this.saveProject();
      },
      showNewLocationModal: function() { document.getElementById("newLocationModal").classList.add("visible"); },
      closeNewLocationModal: function() { document.getElementById("newLocationModal").classList.remove("visible"); },
      createNewLocation: async function() {
        const locationName = document.getElementById("newLocationName").value.trim();
        if (!locationName) {
          alert("Please enter a location name");
          return;
        }
        try {
          const response = await fetch("/api/create_location", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ location_name: locationName })
          });
          const data = await response.json();
          console.log("Location created:", data);

          // Update status immediately
          document.getElementById('dbStatus').textContent = `Current location: ${data.name}`;

          this.closeNewLocationModal();

          // Switch to the new location
          this.switchToLocation(data.id);

          // Refresh the location list
          this.showSwitchLocationModal();
        } catch (e) {
          console.error("Error creating location:", e);
          alert("Failed to create location");
        }
      },
      showSwitchLocationModal: async function() {
        document.getElementById("switchLocationModal").classList.add("visible");
        let locationList = document.getElementById("locationList");
        locationList.innerHTML = "";
        try {
          const response = await fetch("/api/locations");
          const data = await response.json();
          data.locations.forEach(loc => {
            let div = document.createElement("div");
            div.style.padding = "10px";
            div.style.borderBottom = "1px solid #eee";
            div.style.cursor = "pointer";
            div.textContent = `${loc.name} (Created: ${new Date(loc.created_at).toLocaleString()})`;
            div.addEventListener("click", () => this.switchToLocation(loc.id));
            locationList.appendChild(div);
          });
        } catch (e) {
          console.error("Error loading locations:", e);
          locationList.textContent = "Failed to load locations";
        }
      },
      closeSwitchLocationModal: function() { document.getElementById("switchLocationModal").classList.remove("visible"); },
      switchToLocation: async function(locationId) {
        try {
          const response = await fetch(`/api/load-layers?location_id=${locationId}`);
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Error loading location: ${errorData.error || response.statusText}`);
          }

          const data = await response.json();
          console.log("Location data loaded:", data);

          // Clear existing layers
          this.clearLayers();

          // Set current location
          this.currentLocationId = locationId;
          this.currentLocationName = data.name || "Unknown";

          // Update the status display
          document.getElementById('dbStatus').textContent = `Current location: ${data.name}`;

          // Load all layers for this location
          await this.loadProject();

          // Save as last used location in localStorage
          localStorage.setItem('lastLocationId', locationId);
          localStorage.setItem('lastLocationName', data.name);

          // Close the modal after switching
          this.closeSwitchLocationModal();
        } catch (error) {
          console.error("Error switching location:", error);
          setStatusMessage(`Error loading location: ${error.message}`, 'error');
        }
      },
      saveProject: function() {
        try {
          console.log("Starting saveProject function");
          let savedData = {
            layers: {},
            currentLocationName: this.currentLocationName || "",
            currentLocationId: this.currentLocationId || null
          };

          for (const layerName in this.layers) {
            if (!this.layers[layerName]) continue;

            console.log(`Processing layer: ${layerName}`);
            const layer = this.layers[layerName];

            const layerInfo = {
              color: this.layerColors[layerName] || "#3388ff",
              features: []
            };

            layer.eachLayer(function(l) {
              if (l.toGeoJSON) {
                const feature = l.toGeoJSON();

                feature.properties = feature.properties || {};
                feature.properties.layerName = layerName;

                if (l.options) {
                  feature.properties.style = {
                    color: l.options.color,
                    fillColor: l.options.fillColor,
                    weight: l.options.weight,
                    opacity: l.options.opacity,
                    fillOpacity: l.options.fillOpacity
                  };
                }

                if (l._popup) {
                  feature.properties.popupContent = l._popup._content;
                }

                layerInfo.features.push(feature);
              }
            });

            savedData.layers[layerName] = layerInfo;
          }

          localStorage.setItem('qdproProject', JSON.stringify(savedData));
          console.log("Project saved to localStorage:", savedData);

          sessionStorage.setItem('qdproProject', JSON.stringify(savedData));

          this.saveToServer(savedData);

          return true;
        } catch (error) {
          console.error("Error in saveProject:", error);
          alert("Error saving project: " + error.message);
          return false;
        }
      },

      saveToServer: function(data) {
        const features = [];

        for (const layerName in data.layers) {
          const layerData = data.layers[layerName];
          layerData.features.forEach(feature => {
            feature.layerName = layerName;
            features.push(feature);
          });
        }

        fetch('/api/save-layers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            features: features,
            layer_name: "all_layers",
            location_id: data.currentLocationId || null
          })
        })
        .then(response => response.json())
        .then(data => {
          console.log("Project saved successfully to server:", data);
        })
        .catch(error => {
          console.error("Error saving project to server:", error);
        });
      },

      loadProject: async function() {
        try {
          console.log("Starting loadProject function");

          const urlParams = new URLSearchParams(window.location.search);
          const locationId = urlParams.get('location_id');
          if (locationId) {
            await this.loadLocation(locationId);
            return;
          }

          const savedProject = localStorage.getItem('qdproProject');
          if (!savedProject) {
            console.log("No saved project found in localStorage");
            return false;
          }

          console.log("Found saved project in localStorage");
          let projectData;

          try {
            projectData = JSON.parse(savedProject);
            console.log("Parsed project data:", projectData);
          } catch (e) {
            console.error("Failed to parse saved project:", e);
            return false;
          }

          this.clearLayers();

          if (projectData.currentLocationName) {
            this.currentLocationName = projectData.currentLocationName;
            updateLocationDisplay(projectData.currentLocationName);
          }

          if (projectData.currentLocationId) {
            this.currentLocationId = projectData.currentLocationId;
          }

          for (const layerName in projectData.layers) {
            const layerData = projectData.layers[layerName];
            console.log(`Processing saved layer: ${layerName}`, layerData);

            const layer = L.featureGroup();

            if (layerData.color) {
              this.layerColors[layerName] = layerData.color;
            }

            if (layerData.features && layerData.features.length > 0) {
              layerData.features.forEach(feature => {
                let style = {};
                if (feature.properties && feature.properties.style) {
                  style = feature.properties.style;
                } else {
                  style = {
                    color: this.layerColors[layerName] || "#3388ff",
                    fillColor: this.layerColors[layerName] || "#3388ff",
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 0.2
                  };
                }

                const geoJSONLayer = L.geoJSON(feature, {
                  style: style,
                  onEachFeature: (feature, layer) => {
                    if (feature.properties && feature.properties.popupContent) {
                      layer.bindPopup(feature.properties.popupContent);
                    }

                    this.addLayerClickHandlers(layer);
                  }
                });

                geoJSONLayer.eachLayer(l => {
                  layer.addLayer(l);
                });
              });
            }

            layer.addTo(this.map);
            this.layers[layerName] = layer;
          }

          this.updateLayerToggle();
          console.log("Project loaded successfully");
          return true;
        } catch (error) {
          console.error("Error loading project:", error);
          return false;
        }
      },
      clearLayers: function(clearBaseLayersToo = false) {
        // Remove all user-created layers
        for (const [id, layer] of Object.entries(this.layers)) {
          if (this.map.hasLayer(layer)) {
            this.map.removeLayer(layer);
          }
        }

        // Reset layer tracking but preserve base layers
        if (clearBaseLayersToo) {
          this.layers = {};
          this.layerColors = {};
          this.activeLayerId = null;
        } else {
          // Keep a copy of base layers if they exist
          const baseLayersCopy = {};
          const baseColorssCopy = {};

          Object.keys(this.layers).forEach(key => {
            if (key.startsWith('base_')) {
              baseLayersCopy[key] = this.layers[key];
              baseColorssCopy[key] = this.layerColors[key];
                        }          });

          this.layers = baseLayersCopy;
          this.layerColors = baseColorssCopy;
          this.activeLayerId = null;
        }

        // Update the draw-to layer dropdown
        this.updateDrawToLayerSelect();
      },
      addLayerClickHandlers: function(layer) {
        layer.on({
          click: (e) => {
            console.log('Layer clicked:', e.latlng);
          }
        });
      },
      updateLayerToggle: function() {
        this.updateDrawToLayerSelect();
        const layerNames = Object.keys(this.layers);
        if (layerNames.length > 0) {
          const selectElement = document.getElementById("drawToLayer");
          if (selectElement) {
            selectElement.value = layerNames[0];
            this.switchDrawToLayer();
          }
        }
        // Attempt to fit bounds after loading
        if (Object.keys(this.layers).length > 0) {
          try {
            let hasValidBounds = false;
            let bounds = L.latLngBounds([]);

            for (let layerName in this.layers) {
              const layer = this.layers[layerName];
              if (layer.getLayers().length > 0) {
                try {
                  const layerBounds = layer.getBounds();
                  if (layerBounds.isValid()) {
                    bounds.extend(layerBounds);
                    hasValidBounds = true;
                  }
                } catch (e) {
                  console.warn(`Layer ${layerName} has invalid bounds:`, e);
                }
              }
            }

            if (hasValidBounds) {
              this.map.fitBounds(bounds);
            } else {
              console.log("No valid bounds found, using default view");
            }
          } catch (e) {
            console.warn("Error fitting bounds:", e);
          }
        }
      },
      getLayerNameByObject: function(layerObj) {
        for (let name in this.layers) {
          if (this.layers[name] === layerObj) {
            return name;
          }
        }
        return null;
      },
      loadLocation: async function(locationId) {
        try {
          const response = await fetch(`/api/load-layers?location_id=${locationId}`);
          const data = await response.json();
          if (data.name) {
            this.currentLocationName = data.name;
            updateLocationDisplay(data.name);
            this.currentLocationId = locationId;
          }

          this.clearLayers();
          this.activeLayer = L.featureGroup().addTo(this.map);
          this.layers["Default"] = this.activeLayer;
          this.updateDrawToLayerSelect();
          await this.loadProject();
        } catch (error) {
          console.error("Error loading location:", error);
          alert(`Failed to load location with ID ${locationId}`);
        }
      },
      getRandomColor: function() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      },
      addLayer: function(layerName, layerColor) {
        const newLayer = L.featureGroup().addTo(this.map);
        this.layers[layerName] = newLayer;
        this.layerColors[layerName] = layerColor;
        return newLayer;
      }
    };

    function setStatusMessage(message, type) {
      const statusElement = document.getElementById('dbStatus');
      statusElement.textContent = message;
      statusElement.classList.remove('success', 'error', 'info');
      statusElement.classList.add(type);
    }

    function clearAllLayers() {
      QDPro.clearLayers();
    }


    function showNewLocationModal() { QDPro.showNewLocationModal(); }
    function closeNewLocationModal() { QDPro.closeNewLocationModal(); }
    function createNewLocation() { QDPro.createNewLocation(); }
    function showSwitchLocationModal() { QDPro.showSwitchLocationModal(); }
    function closeSwitchLocationModal() { QDPro.closeSwitchLocationModal(); }
    function showAddLayerModal() { QDPro.showAddLayerModal(); }
    function closeAddLayerModal() { QDPro.closeAddLayerModal(); }
    function createNewLayer() { QDPro.createNewLayer(); }
    function saveProject() { QDPro.saveProject(); }
    function loadProject() { QDPro.loadProject(); }

    // Initialize status display
    document.getElementById('dbStatus').textContent = "No location loaded";

    // Load last used location if available
    (async function loadLastLocation() {
      const lastLocationId = localStorage.getItem('lastLocationId');
      if (lastLocationId) {
        try {
          console.log("Loading last used location:", lastLocationId);
          await QDPro.switchToLocation(parseInt(lastLocationId, 10));
          console.log("Last location loaded successfully");
        } catch (error) {
          console.error("Failed to load last location:", error);
          document.getElementById('dbStatus').textContent = "No location loaded";
        }
      }
    })();

    // Add database connection status check
    async function checkDatabaseConnection() {
      try {
        const response = await fetch('/api/db_status');
        if (response.ok) {
          // Only update if no location is currently displayed
          const currentStatus = document.getElementById('dbStatus').textContent;
          if (!currentStatus.includes("Location:")) {
            document.getElementById('dbStatus').textContent = "Database connection successful";
          }
        } else {
          document.getElementById('dbStatus').textContent = "Database connection failed";
        }
      } catch (e) {
        document.getElementById('dbStatus').textContent = "Database connection error";
      }
    }

    // Check database connection on page load
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(checkDatabaseConnection, 1000);
    });

    //Helper function to update location display
    function updateLocationDisplay(locationName) {
      document.getElementById('dbStatus').textContent = `Location: ${locationName}`;
    }

    document.addEventListener("DOMContentLoaded", () => QDPro.init());
  </script>
  <script src="/static/js/custom-modal.js"></script>
</body>
</html>
<script>
  // Add these functions to your existing QDPro object
  
  // Add new menu items to your File menu
  document.addEventListener('DOMContentLoaded', function() {
    // Add Analysis menu items to your existing menu structure
    const fileMenu = document.querySelector("#fileMenu");
    if (fileMenu) {
      const analysisMenuItem = document.createElement("li");
      analysisMenuItem.innerHTML = '<a href="#" onclick="QDPro.showQDAnalysisModal()">QD Analysis...</a>';
      fileMenu.appendChild(analysisMenuItem);
    }
    
    // Add to QDPro object
    if (window.QDPro) {
      Object.assign(QDPro, {
        currentAnalysisId: null,
        analysisResults: null,
        
        showQDAnalysisModal: function() {
          // Populate feature dropdown
          const featureSelect = document.getElementById("analysis-feature");
          featureSelect.innerHTML = '<option value="">Select a feature...</option>';
          
          // Get all drawable features
          const allFeatures = [];
          for (let layerName in this.layers) {
            if (this.layers[layerName] && this.layers[layerName].getLayers) {
              this.layers[layerName].getLayers().forEach(layer => {
                if (layer.feature && layer.feature.properties) {
                  const featureId = layer.feature.id || layer._leaflet_id;
                  const featureName = layer.feature.properties.name || `Feature #${featureId}`;
                  allFeatures.push({
                    id: featureId,
                    name: featureName,
                    layer: layer
                  });
                }
              });
            }
          }
          
          // Add options to select
          allFeatures.forEach(feature => {
            const option = document.createElement("option");
            option.value = feature.id;
            option.text = feature.name;
            featureSelect.appendChild(option);
          });
          
          document.getElementById("qd-analysis-modal").style.display = "block";
        },
        
        runQDAnalysis: async function() {
          const featureId = document.getElementById("analysis-feature").value;
          if (!featureId) {
            alert("Please select a feature to analyze");
            return;
          }
          
          const quantity = parseFloat(document.getElementById("analysis-quantity").value);
          if (isNaN(quantity) || quantity <= 0) {
            alert("Please enter a valid quantity");
            return;
          }
          
          const kFactor = parseFloat(document.getElementById("analysis-k-factor").value);
          const siteType = document.getElementById("analysis-site-type").value;
          
          // Collect all features for analysis
          const allFeatures = [];
          for (let layerName in this.layers) {
            if (this.layers[layerName] && this.layers[layerName].getLayers) {
              this.layers[layerName].getLayers().forEach(layer => {
                if (layer.feature) {
                  allFeatures.push(layer.feature);
                }
              });
            }
          }
          
          // Close analysis modal
          document.getElementById("qd-analysis-modal").style.display = "none";
          
          // Show loading indicator
          this.showLoadingMessage("Running QD analysis...");
          
          try {
            // Prepare request data
            const requestData = {
              feature_id: featureId,
              location_id: this.currentLocationId,
              site_type: siteType,
              quantity: quantity,
              k_factor: kFactor,
              features_to_analyze: allFeatures,
              material_props: {
                sensitivity: 1.0,
                det_velocity: 6000,
                tnt_equiv: 1.0
              },
              env_conditions: {
                temperature: 298,
                pressure: 101.325,
                humidity: 50,
                confinement_factor: 0.0
              }
            };
            
            // Send analysis request
            const response = await fetch("/api/analyze-qd", {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(requestData)
            });
            
            if (!response.ok) {
              throw new Error(`Error ${response.status}: ${await response.text()}`);
            }
            
            // Get analysis results
            const analysisData = await response.json();
            console.log("Analysis results:", analysisData);
            
            // Store results
            this.currentAnalysisId = analysisData.analysis_id;
            this.analysisResults = analysisData;
            
            // Clear any existing buffer zones
            if (this.layers["QD_Buffers"]) {
              this.map.removeLayer(this.layers["QD_Buffers"]);
            }
            
            // Add buffer zones to map
            this.layers["QD_Buffers"] = L.geoJSON(analysisData.buffer_zones, {
              style: function(feature) {
                // Different colors for different k factors
                const kFactor = feature.properties.k_factor;
                let color = "#FF0000";  // Default red
                
                if (kFactor <= 1.0) color = "#FF0000";  // Red
                else if (kFactor <= 1.5) color = "#FF6600";  // Orange
                else if (kFactor <= 2.0) color = "#FFCC00";  // Yellow
                else color = "#66CC00";  // Green
                
                return {
                  fillColor: color,
                  weight: 2,
                  opacity: 0.7,
                  color: 'white',
                  dashArray: '3',
                  fillOpacity: 0.3
                };
              }
            }).addTo(this.map);
            
            // Update results modal
            document.getElementById("analysis-feature-name").textContent = 
              document.getElementById("analysis-feature").options[document.getElementById("analysis-feature").selectedIndex].text;
            document.getElementById("analysis-safe-distance").textContent = analysisData.safe_distance;
            document.getElementById("analysis-quantity-display").textContent = quantity;
            document.getElementById("analysis-k-factor-display").textContent = kFactor;
            
            // Populate results table
            const resultsBody = document.getElementById("analysis-results-body");
            resultsBody.innerHTML = "";
            
            if (analysisData.analysis_results && analysisData.analysis_results.length > 0) {
              analysisData.analysis_results.forEach(result => {
                const row = document.createElement("tr");
                const statusClass = result.is_safe ? "text-success" : "text-danger";
                
                row.innerHTML = `
                  <td>${result.name || 'Unnamed'}</td>
                  <td>${result.distance}</td>
                  <td>${result.required_distance}</td>
                  <td class="${statusClass}">${result.status}</td>
                `;
                
                resultsBody.appendChild(row);
              });
            } else {
              resultsBody.innerHTML = '<tr><td colspan="4">No exposed features found</td></tr>';
            }
            
            // Show results modal
            document.getElementById("analysis-results-modal").style.display = "block";
            
          } catch (error) {
            console.error("Error running analysis:", error);
            alert("Error running analysis: " + error.message);
          } finally {
            this.hideLoadingMessage();
          }
        },
        
        saveAnalysisLayer: function() {
          if (!this.analysisResults || !this.analysisResults.buffer_zones) {
            alert("No analysis results to save");
            return;
          }
          
          // Add buffer zones to saved layers
          const featureName = document.getElementById("analysis-feature-name").textContent;
          const layerName = `QD Analysis: ${featureName}`;
          
          // Create a layer with the buffer zones
          if (!this.layers["Analysis"]) {
            this.layers["Analysis"] = L.featureGroup().addTo(this.map);
          }
          
          const bufferLayer = L.geoJSON(this.analysisResults.buffer_zones, {
            style: function(feature) {
              const kFactor = feature.properties.k_factor;
              let color = "#FF0000";
              
              if (kFactor <= 1.0) color = "#FF0000";
              else if (kFactor <= 1.5) color = "#FF6600";
              else if (kFactor <= 2.0) color = "#FFCC00";
              else color = "#66CC00";
              
              return {
                fillColor: color,
                weight: 2,
                opacity: 0.7,
                color: 'white',
                dashArray: '3',
                fillOpacity: 0.3
              };
            }
          });
          
          // Add to Analysis layer
          bufferLayer.getLayers().forEach(layer => {
            if (layer.feature) {
              layer.feature.properties.analysisId = this.currentAnalysisId;
              layer.feature.properties.name = layerName;
              layer.feature.properties.description = `QD Analysis for ${featureName}`;
              layer.feature.properties.analysisDate = new Date().toISOString();
              this.layers["Analysis"].addLayer(layer);
            }
          });
          
          // Save to backend
          this.saveLayersToBackend("Analysis");
          
          alert("Analysis layer saved successfully");
        },
        
        generateReport: function() {
          if (!this.currentAnalysisId) {
            alert("No analysis results to generate report");
            return;
          }
          
          // Show report generation modal
          document.getElementById("report-modal").style.display = "block";
        },
        
        createReport: async function() {
          if (!this.currentAnalysisId) {
            alert("No analysis results to generate report");
            return;
          }
          
          const reportTitle = document.getElementById("report-title").value || "QD Safety Analysis Report";
          const includeMap = document.getElementById("include-map").checked;
          
          // Close report modal
          document.getElementById("report-modal").style.display = "none";
          
          // Show loading indicator
          this.showLoadingMessage("Generating report...");
          
          try {
            // Capture map screenshot if needed
            let mapScreenshot = null;
            if (includeMap) {
              mapScreenshot = await this.captureMapScreenshot();
            }
            
            // Prepare request data
            const requestData = {
              title: reportTitle,
              analysis_id: this.currentAnalysisId,
              location_id: this.currentLocationId,
              include_map: includeMap,
              map_snapshot: mapScreenshot
            };
            
            // Send report generation request
            const response = await fetch("/api/generate-report", {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(requestData)
            });
            
            if (!response.ok) {
              throw new Error(`Error ${response.status}: ${await response.text()}`);
            }
            
            const reportData = await response.json();
            console.log("Report generated:", reportData);
            
            // Open report in new window/tab
            if (reportData.filename) {
              window.open(`/api/reports/${reportData.report_id}`, '_blank');
            }
            
            alert("Report generated successfully!");
            
          } catch (error) {
            console.error("Error generating report:", error);
            alert("Error generating report: " + error.message);
          } finally {
            this.hideLoadingMessage();
          }
        },
        
        captureMapScreenshot: function() {
          return new Promise((resolve) => {
            // Use html2canvas to capture the map
            if (window.html2canvas) {
              html2canvas(document.getElementById("map")).then(canvas => {
                const imageData = canvas.toDataURL("image/png");
                resolve(imageData);
              });
            } else {
              console.warn("html2canvas not available, skipping map screenshot");
              resolve(null);
            }
          });
        },
        
        showLoadingMessage: function(message) {
          // Create loading div if it doesn't exist
          let loadingEl = document.getElementById("loading-message");
          if (!loadingEl) {
            loadingEl = document.createElement("div");
            loadingEl.id = "loading-message";
            loadingEl.style.position = "fixed";
            loadingEl.style.top = "50%";
            loadingEl.style.left = "50%";
            loadingEl.style.transform = "translate(-50%, -50%)";
            loadingEl.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
            loadingEl.style.color = "white";
            loadingEl.style.padding = "20px";
            loadingEl.style.borderRadius = "5px";
            loadingEl.style.zIndex = "9999";
            document.body.appendChild(loadingEl);
          }
          
          loadingEl.textContent = message || "Loading...";
          loadingEl.style.display = "block";
        },
        
        hideLoadingMessage: function() {
          const loadingEl = document.getElementById("loading-message");
          if (loadingEl) {
            loadingEl.style.display = "none";
          }
        }
      });
    }
  });
</script>
